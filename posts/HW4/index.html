<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.541">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jamie">
<meta name="dcterms.date" content="2024-02-23">

<title>Jamie’s Blog - Accelerate The Heat Diffusion!</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Jamie’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Accelerate The Heat Diffusion!</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">HOMEWORK</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jamie </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 23, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Conduct a simulation of two-dimensional heat diffusion in various ways</p>
<div id="9e3a4f86-b62c-4425-87fd-14330359f0b7" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the default Plotly renderer to "iframe"</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.io <span class="im">as</span> pio</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>pio.renderers.default <span class="op">=</span> <span class="st">"iframe"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="table-of-contents" class="level2">
<h2 class="anchored" data-anchor-id="table-of-contents">Table of Contents</h2>
<section id="introduction" class="level3">
<h3 class="anchored" data-anchor-id="introduction">1. Introduction</h3>
</section>
<section id="initial-conditions" class="level3">
<h3 class="anchored" data-anchor-id="initial-conditions">2. Initial conditions</h3>
</section>
<section id="methods" class="level3">
<h3 class="anchored" data-anchor-id="methods">3. Methods</h3>
<pre><code>3.1 Matrix Multiplication
3.2 Sparse matrix in JAX
3.3 Direct operation with `numpy`
3.4 Direction operation with `jax`</code></pre>
</section>
</section>
<section id="introduction-1" class="level2">
<h2 class="anchored" data-anchor-id="introduction-1">1. Introduction</h2>
<p>Two-dimensional heat diffusion refers to the process by which heat spreads across a surface or within a two-dimensional region over time. It’s governed by the heat equation, which describes how the temperature at any point in the region changes over time due to the flow of heat.</p>
<p>The heat equation in two dimensions can be expressed as:</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} = \alpha \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} \right)
\]</span></p>
<p>Where: - <span class="math inline">\(u\)</span> is the temperature distribution across the two-dimensional region, which typically depends on the spatial coordinates <span class="math inline">\((x, y)\)</span> and time <span class="math inline">\(t\)</span>. - <span class="math inline">\(\alpha\)</span> is the thermal diffusivity, which represents how readily heat spreads through the material. - <span class="math inline">\(\frac{{\partial u}}{{\partial t}}\)</span> represents the rate of change of temperature with respect to time. - <span class="math inline">\(\frac{{\partial^2 u}}{{\partial x^2}}\)</span> and <span class="math inline">\(\frac{{\partial^2 u}}{{\partial y^2}}\)</span> represent the second spatial derivatives of temperature with respect to the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> coordinates, respectively. They describe how temperature changes spatially along the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> directions.</p>
<p>The heat equation essentially states that the change in temperature at any point is proportional to the rate of change of temperature over time and the spatial curvature of the temperature distribution.</p>
<p>To simulate two-dimensional heat diffusion numerically, we discretize the region into a grid of points. At each point on the grid, we calculate the change in temperature over time based on the temperature differences with neighboring points, following the heat equation. This can be done using finite difference methods or other numerical techniques.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/e25d3a57-7a1c-4395-b073-870cd73eddb6-1-7597a5f8-2ad2-4b44-bf6d-b2dd0b90e2e6.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
<p>The simulation proceeds in discrete time steps, with the temperature at each point being updated based on the temperatures of neighboring points and the thermal diffusivity. Over time, the heat spreads from hotter regions to cooler regions, gradually evening out the temperature distribution until it reaches equilibrium.</p>
<p>Visualizing the simulation results often involves plotting heatmaps or contour plots, showing how the temperature evolves across the two-dimensional region over time.</p>
<p>Let’s get start it!</p>
</section>
<section id="initial-conditions-1" class="level2">
<h2 class="anchored" data-anchor-id="initial-conditions-1">2. Initial conditions</h2>
<div id="d34c80a7-34a4-486b-95b9-9d2fefc64cdc" class="cell" data-tags="[]" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import libraries (you should be familiar with these 2!)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For this tutorial, we will use:</p>
<div id="d9487b81-606a-40c0-ab8b-157865962477" class="cell" data-tags="[]" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># set the grid to have 101 rows and 101 columns.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">101</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># stability constant or the time step size used in numerical simulations we use is 0.2</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>epsilon <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># construct initial condition: 1 unit of heat at midpoint</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize a two-dimensional NumPy array `u0` of size `N` by `N`, filled with zeros. This array represents the initial temperature distribution across the grid.</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>u0 <span class="op">=</span> np.zeros((N, N))</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co"># sets the value at the center of the grid to 1.0, representing one unit of heat. </span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># The expression `int(N/2)` calculates the index of the center of the grid in both dimensions, and the value 1.0 is assigned to that cell</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>u0[<span class="bu">int</span>(N<span class="op">/</span><span class="dv">2</span>), <span class="bu">int</span>(N<span class="op">/</span><span class="dv">2</span>)] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co"># This function displays the array as an image, where each element of the array corresponds to a pixel in the image, and the value of the element determines the color of the pixel. </span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Since `u0` is a two-dimensional array, `imshow()` will display a heatmap where lighter colors represent higher temperatures and darker colors represent lower temperatures.</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>plt.imshow(u0)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="methods-1" class="level2">
<h2 class="anchored" data-anchor-id="methods-1">3. Methods</h2>
<section id="matrix-multiplication" class="level3">
<h3 class="anchored" data-anchor-id="matrix-multiplication">3.1 Matrix Multiplication</h3>
<div id="bc879615-a70b-4db7-a09c-6d64744b2ece" class="cell" data-tags="[]" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># you might have seen this in the climate change tutorial before</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> inspect</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heat_equation <span class="im">import</span> advance_time_matvecmul</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heat_equation <span class="im">import</span> get_A</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the source code of the 'advance_time_matvecmul' function</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.getsource(advance_time_matvecmul))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def advance_time_matvecmul(A, u, epsilon):
    """Advances the simulation by one timestep, via matrix-vector multiplication
    Args:
        A: The 2d finite difference matrix, N^2 x N^2. 
        u: N x N grid state at timestep k.
        epsilon: stability constant.

    Returns:
        N x N Grid state at timestep k+1.
    """
    N = int(np.sqrt(A.shape[0]))
    u = u + epsilon * (A @ u.flatten()).reshape((N, N))
    return u
</code></pre>
</div>
</div>
<p><code>advance_time_matvecmul</code> advances a simulation of the heat equation by one timestep using matrix-vector multiplication.</p>
<p>Let’s break down the function and its components:</p>
<ol type="1">
<li><p><code>advance_time_matvecmul</code> takes three parameters:</p>
<ul>
<li><code>A</code>: The 2D finite difference matrix representing the discretized differential operator of the heat equation. It has dimensions <span class="math inline">\(N^2\)</span> times <span class="math inline">\(N^2\)</span>.</li>
<li><code>u</code>: The current state of the temperature grid at timestep k. It’s a 2D array with dimensions N times N.</li>
<li><code>epsilon</code>: The stability constant or time step size used in the simulation.</li>
</ul></li>
<li><p><code>N = int(np.sqrt(A.shape[0]))</code>: calculates the size of the grid based on the shape of the finite difference matrix <code>A</code>. Since <code>A</code> is square with dimensions <span class="math inline">\(N^2\)</span> times <span class="math inline">\(N^2\)</span>, the square root of the number of rows (or columns) gives us N, the size of the grid in one dimension.</p></li>
<li><p><code>u = u + epsilon * (A @ u.flatten()).reshape((N, N))</code>: advances the temperature grid <code>u</code> by one timestep. It does this by performing matrix-vector multiplication between the finite difference matrix <code>A</code> and the flattened temperature grid <code>u</code>. The result is then reshaped to a 2D array with dimensions N times N. This operation represents the application of the discrete heat equation to update the temperature distribution.</p></li>
<li><p><code>return u</code>: returns the updated temperature grid after advancing it by one timestep.</p></li>
</ol>
<p>In summary, this function takes the current state of the temperature grid, applies the heat equation using matrix-vector multiplication, and returns the updated temperature grid for the next timestep.</p>
<div id="e57a127d-a03f-425e-aa2e-eee932c538e8" class="cell" data-tags="[]" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the source code of the 'get_A' function</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.getsource(get_A))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def get_A(N):
    """
    Constructs the finite difference matrix A for a 2D Laplace operator.

    Parameters:
    - N: int
        The size of the grid in one dimension.

    Returns:
    array_like
        The finite difference matrix A representing the discretized Laplace operator.

    This function constructs the finite difference matrix A for a 2D Laplace operator based on the size of the grid N.
    The Laplace operator is discretized using a five-point stencil finite difference scheme.
    The resulting matrix A is a square matrix of size N^2 x N^2.

    """
    n = N * N
    diagonals = [-4 * np.ones(n), np.ones(n-1), np.ones(n-1), np.ones(n-N), np.ones(n-N)]
    diagonals[1][(N-1)::N] = 0
    diagonals[2][(N-1)::N] = 0
    A = np.diag(diagonals[0]) + np.diag(diagonals[1], 1) + np.diag(diagonals[2], -1) + np.diag(diagonals[3], N) + np.diag(diagonals[4], -N)
    return A
</code></pre>
</div>
</div>
<p><code>get_A(N)</code> generates the finite difference matrix <code>A</code> for the 2D discretization of the Laplace operator.</p>
<p>Let’s break down the function and its components: 1. <code>get_A</code> that takes a single parameter <code>N</code>, which represents the size of the grid in one dimension.</p>
<ol start="2" type="1">
<li><p><code>n = N * N</code>: calculates the total number of grid points in the 2D grid by squaring the size of the grid in one dimension.</p></li>
<li><p><code>diagonals = [-4 * np.ones(n), np.ones(n-1), np.ones(n-1), np.ones(n-N), np.ones(n-N)]</code>: initializes a list <code>diagonals</code> containing arrays representing the diagonals of the finite difference matrix <code>A</code>.</p>
<ul>
<li>The first diagonal is set to -4 for each element (corresponding to the main diagonal).</li>
<li>The second and third diagonals are set to 1 for each element, except for the last element in each row, where the value is 0. This is because these diagonals represent the elements directly adjacent to the main diagonal, excluding the edges.</li>
<li>The fourth and fifth diagonals are also set to 1, representing the elements that are N positions away from the main diagonal, corresponding to the elements above and below the main diagonal.</li>
</ul></li>
<li><p><code>diagonals[1][(N-1)::N] = 0</code> and <code>diagonals[2][(N-1)::N] = 0</code>: set the elements of the second and third diagonals to 0 at the positions corresponding to the last element in each row. This is done to ensure that the finite difference matrix <code>A</code> respects the boundary conditions of the grid.</p></li>
<li><p><code>A = np.diag(diagonals[0]) + np.diag(diagonals[1], 1) + np.diag(diagonals[2], -1) + np.diag(diagonals[3], N) + np.diag(diagonals[4], -N)</code>: constructs the finite difference matrix <code>A</code> by summing the diagonals specified in the <code>diagonals</code> list.</p>
<ul>
<li><code>np.diag(diagonals[0])</code> constructs a diagonal matrix using the main diagonal elements.</li>
<li><code>np.diag(diagonals[1], 1)</code> constructs a diagonal matrix using the elements from the second diagonal shifted one position to the right.</li>
<li><code>np.diag(diagonals[2], -1)</code> constructs a diagonal matrix using the elements from the third diagonal shifted one position to the left.</li>
<li><code>np.diag(diagonals[3], N)</code> constructs a diagonal matrix using the elements from the fourth diagonal shifted N positions down.</li>
<li><code>np.diag(diagonals[4], -N)</code> constructs a diagonal matrix using the elements from the fifth diagonal shifted N positions up.</li>
<li>The matrices are then summed together to obtain the final finite difference matrix <code>A</code>.</li>
</ul></li>
<li><p><code>return A</code>: returns the constructed finite difference matrix <code>A</code>.</p></li>
</ol>
<p>In summary, this function generates the finite difference matrix <code>A</code> for the 2D discretization of the Laplace operator based on the size of the grid <code>N</code>, taking into account the boundary conditions. This matrix is then used in <code>advance_time_matvecmul</code>.</p>
<div id="2dc80257-e3f6-4383-aa0c-51cff7d3de09" class="cell" data-tags="[]" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> timeit <span class="im">import</span> default_timer</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> heat_plot(f, u0, epsilon, A<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Visualizes the progression of a simulation over multiple time steps.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">    - f: function</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">        The method used to advance the simulation by one time step. </span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co">        If A is provided, f should take three parameters (A, u, epsilon). </span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Otherwise, f should take two parameters (u, epsilon).</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - u0: array_like</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co">        The initial state of the simulation.</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co">    - epsilon: float</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">        The stability constant or time step size.</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co">    - A: array_like, optional</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co">        The finite difference matrix representing the discretized differential operator of the simulation.</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="co">    None</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="co">    This function iterates over the specified number of time steps, advances the simulation using the provided method f,</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="co">    and visualizes the progression of the simulation at milestone iterations. It also prints the total computation time.</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    intermediate_solutions <span class="op">=</span> []</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> default_timer()</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> u0.copy() </span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">2701</span>):</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> A <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> f(A,u,epsilon)</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> f(u, epsilon)</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">%</span> <span class="dv">300</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>            intermediate_solutions.append(u.copy())</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>    end <span class="op">=</span> default_timer()</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>    computation_time <span class="op">=</span> end <span class="op">-</span> start</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total computation time: </span><span class="sc">{</span>computation_time<span class="sc">}</span><span class="ss"> seconds"</span>)</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>    fig, axs <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">12</span>))</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> i <span class="op">*</span> <span class="dv">3</span> <span class="op">+</span> j</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>            axs[i, j].imshow(intermediate_solutions[idx], interpolation<span class="op">=</span><span class="st">'nearest'</span>)</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>            axs[i, j].set_title(<span class="ss">f"Iteration </span><span class="sc">{</span>idx <span class="op">*</span> visualization_interval<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>    plt.show() </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Just for convenience, I created a generic function for visualizing the progression of a simulation over multiple time steps.</p>
<p>Let’s break it down: 1. <code>heat_plot</code> that takes four parameters: - <code>f</code>: A function representing the method used to advance the simulation by one time step. It can either take two parameters (<code>u</code>, <code>epsilon</code>) or three parameters (<code>A</code>, <code>u</code>, <code>epsilon</code>) depending on whether <code>A</code> is provided or not. - <code>u0</code>: The initial state of the simulation. - <code>epsilon</code>: A parameter representing the stability constant or time step size. - <code>A</code>: (Optional) The finite difference matrix representing the discretized differential operator of the simulation.</p>
<ol start="2" type="1">
<li><p><code>intermediate_solutions = []</code>: initializes an empty list to store intermediate states of the simulation for visualization purposes since we should not cont the time for generating plot so we should store it for ploting use with a frequency of 300.</p></li>
<li><p><code>start = default_timer()</code>: records the start time of the computation.</p></li>
<li><p><code>u = u0.copy()</code>: creates a copy of the initial state <code>u0</code> to ensure that the original state is not modified during the simulation.</p></li>
<li><p><code>for i in range(1,2701):</code>: starts a loop iterating over the range from 1 to 2700 (inclusive), representing the number of time steps in the simulation.</p></li>
<li><p><code>if A is not None:</code>: checks if the finite difference matrix <code>A</code> is provided. If it is not <code>None</code>, it indicates that the function <code>f</code> takes three parameters (<code>A</code>, <code>u</code>, <code>epsilon</code>). Otherwise, it takes two parameters (<code>u</code>, <code>epsilon</code>). For first 2 method, we defined A and for last 2 we are not gonna define it.</p></li>
<li><p><code>u = f(A,u,epsilon)</code> or <code>u = f(u, epsilon)</code>: Depending on whether <code>A</code> is provided or not, this line advances the simulation by one time step using the function <code>f</code>. If <code>A</code> is provided, <code>f</code> is called with three parameters (<code>A</code>, <code>u</code>, <code>epsilon</code>), otherwise with two parameters (<code>u</code>, <code>epsilon</code>).</p></li>
<li><p><code>if i % 300 == 0:</code>: checks if the current iteration is a multiple of 300. If it is, it indicates a milestone iteration for visualization, and the current state <code>u</code> is appended to the <code>intermediate_solutions</code> list.</p></li>
<li><p><code>end = default_timer()</code>: records the end time of the computation.</p></li>
<li><p><code>computation_time = end - start</code>: calculates the total computation time by subtracting the start time from the end time.</p></li>
<li><p><code>print(f"Total computation time: {computation_time} seconds")</code>: prints the total computation time to the console.</p></li>
<li><p>Visualization: This section creates a 3x3 grid of subplots using <code>plt.subplots(3, 3, figsize=(12, 12))</code>. It iterates over the <code>intermediate_solutions</code> list and plots each intermediate state on a subplot. Each subplot is titled with the corresponding iteration number.</p></li>
</ol>
<p>Let me show you the work!</p>
<div id="2946e242-d8fd-4ae7-88e2-95e775620c0d" class="cell" data-tags="[]" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>visualization_interval <span class="op">=</span> <span class="dv">300</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="71cffff7-c365-48fc-b49d-ffabfec72b23" class="cell" data-tags="[]" data-execution_count="7">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> get_A(N)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="c79b1322-22b3-4edf-92d4-a19087ae88f9" class="cell" data-tags="[]" data-execution_count="75">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>heat_plot(advance_time_matvecmul, u0, epsilon, A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total computation time: 20.457517958944663 seconds</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-10-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Beautiful plot but the running time is 20.457517958944663 seconds, which is pretty long. The reason why this took this much of time is that most of operations are wasted for computing zeros.</p>
<p>Let’s use the data structure that exploits a lot of zeros in the matrix A: sparse matrix data structures. The JAX package holds an experimental sparse matrix support. We can use the batched coordinate (BCOO) format to only use O(N^2) space for the matrix, and only take O(N^2) time for each update.</p>
</section>
<section id="sparse-matrix-in-jax" class="level3">
<h3 class="anchored" data-anchor-id="sparse-matrix-in-jax">3.2 Sparse matrix in JAX</h3>
<section id="jax" class="level4">
<h4 class="anchored" data-anchor-id="jax">Jax</h4>
<p><code>JAX</code> is a machine learning package putting autodiff, XLA (accelerated linear algebra), and just-in-time compilation together, created by Google.</p>
<p>In Python, we already have a couple of widely-used machine learning packages, <a href="https://pytorch.org/">PyTorch</a> and <a href="https://www.tensorflow.org/">TensorFlow</a>. Why do we start with something else?</p>
<p><strong>Short answer</strong>: because it can be considerably faster. Over the years, when I was using another just-in-time compilation language for research, it was giving me significant amount of flexibility while maintaining its speed.</p>
<p>Python is a slow language at its core. Its development is highly focused on flexibility. However, due to its flexibility, a lot of highly performant packages were built, often interfacing with other languages. What just-in-time (JIT) compilation adds to it is that you can write highly performant code without you directly dealing with the lower-level language (writing C or C++), even when those functionalities are not readily written in another package (numpy, scipy, tensorflow, or pytorch).</p>
<p>For example, a small neural network model (GoogleNet) on CIFAR10 can be trained in JAX 3x faster than in PyTorch with a similar setup. JAX enables this speedup by compiling functions and numerical programs for accelerators (GPU/TPU) <em>just in time</em>, finding the optimal utilization of the hardware.</p>
<p>Frameworks with dynamic computation graphs like PyTorch cannot achieve the same efficiency, since they cannot anticipate the next operations before the user calls them. For example, in an Inception block of GoogleNet, multiple convolutional layers (which we will learn soon) are applied in parallel on the same input. JAX can optimize the execution of this layer by compiling the whole forward pass for the available accelerator and fusing operations where possible, reducing memory access and speeding up execution.</p>
<p>In contrast, when calling the first convolutional layer in PyTorch, the framework does not know that multiple convolutions on the same feature map will follow. It sends each operation one by one to the GPU, and can only adapt the execution after seeing the next Python calls. Hence, JAX can make more efficient use of the GPU than, for instance, PyTorch.</p>
</section>
<section id="the-downside" class="level4">
<h4 class="anchored" data-anchor-id="the-downside">The downside</h4>
<p>Everything comes with a price. In order to efficiently compile programs just-in-time in JAX, the functions need to be written with certain constraints.</p>
<ol type="1">
<li>Functions are not allowed to have side effects.</li>
</ol>
<ul>
<li>They can’t affect any variable outside their namespaces – “pure functions” in functional programming nomenclature.</li>
<li>Cannot mutate input arrays.</li>
<li>Random number generation procedures are generally written in a way that mutates global states – JAX has its own way to write random number generation.</li>
<li>Even having <code>print()</code> inside a function is a side effect!</li>
</ul>
<p>This kind of functional programming approach is not something unique to JAX in data analytics; it has previously been used in places like Apache Spark, for large-scale parallel data analytics.</p>
<ol start="2" type="1">
<li>JAX compiles functions based on the expected shapes of all arrays/tensors in the function.</li>
</ol>
<ul>
<li>It becomes an issue if the shapes or the control flow within the function depends on the values of arrays.</li>
<li><code>y = x[x&gt;3]</code>?</li>
</ul>
<p>Still, in a lot of numerical computations, it is straightforward to write functions within these constraints.</p>
<p>Many other great JAX tutorials are there, including:</p>
<ul>
<li><a href="https://jax.readthedocs.io/en/latest/jax-101/index.html">JAX 101</a> with many subtutorials on individual parts of JAX</li>
<li><a href="https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html">JAX - The Sharp Bits</a> discusses the constraints of JAX and how to overcome them</li>
<li><a href="https://colab.research.google.com/github/BertrandRdp/flax/blob/master/docs/notebooks/jax_for_the_impatient.ipynb">Jax for the Impatient</a> for a quick intro to JAX with focus on deep learning</li>
</ul>
<div id="e85c3b7c-343a-417d-9baf-6f60888c486d" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax.experimental <span class="im">import</span> sparse</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>sparse</code> module from the <code>jax.experimental</code> package: JAX is a library for numerical computing and automatic differentiation, and it provides experimental support for sparse matrix operations. The <code>sparse</code> module contains functions and data structures for working with sparse matrices in JAX, such as converting between dense and sparse representations, performing sparse matrix-vector multiplication, and solving linear systems with sparse matrices.</p>
<p><code>jnp</code>: NumPy-compatible array manipulation library provided by JAX and aliases it as <code>jnp</code>. JAX’s NumPy (<code>jnp</code>) offers functions and data structures similar to NumPy for manipulating arrays, performing mathematical operations, and working with numerical data. However, JAX’s NumPy is designed to work seamlessly with JAX’s automatic differentiation capabilities, allowing users to compute gradients of functions involving array operations efficiently.</p>
<div id="dc8b5662-c94f-4e67-9f6b-2b0ca43a3fc0" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heat_equation <span class="im">import</span> get_sparse_A</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the source code of the 'get_A_sparse' function</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.getsource(get_sparse_A))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def get_sparse_A(N):
    """
    Constructs a sparse representation of the finite difference matrix A for a 2D Laplace operator.

    Parameters:
    - N: int
        The size of the grid in one dimension.

    Returns:
    sparse.BCOO
        A sparse representation of the finite difference matrix A.

    This function constructs the finite difference matrix A for a 2D Laplace operator based on the size of the grid N,
    and converts it into a sparse representation using the BCOO format.
    The Laplace operator is discretized using a five-point stencil finite difference scheme.
    The resulting sparse matrix A_sp_matrix is a sparse matrix of size N^2 x N^2.

    """
    A = get_A(N)
    A_sp_matrix = sparse.BCOO.fromdense(A)
    return A_sp_matrix
</code></pre>
</div>
</div>
<p>The main high-level sparse object currently available in JAX is the BCOO, or batched coordinate sparse array, which offers a compressed storage format compatible with JAX transformations.</p>
<p>Find more info about BCOO: https://jax.readthedocs.io/en/latest/jax.experimental.sparse.html</p>
<div id="04c22568-f28c-4695-b888-390563eb973c" class="cell" data-tags="[]" data-execution_count="11">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># JIT-ed version of advance_time_matvecmul for better performance</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>advance_time_matvecmul_jit <span class="op">=</span> jax.jit(advance_time_matvecmul)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here’s what it does:</p>
<ol type="1">
<li><p><strong>JIT Compilation</strong>: JAX’s JIT compilation feature allows for efficient execution of functions by compiling them into optimized machine code just before they are executed. This can lead to significant performance improvements, especially for functions that are called frequently or are computationally intensive.</p></li>
<li><p><strong>Compilation on Demand</strong>: When you create a JIT-compiled version of a function, JAX analyzes the function’s computation graph and generates optimized code tailored to the specific inputs it receives. This compilation process occurs on demand, the first time the function is called with a particular set of input shapes and data types.</p></li>
<li><p><strong>Usage of Compiled Function</strong>: After compilation, the resulting JIT-compiled function (<code>advance_time_matvecmul_jit</code> in this case) behaves like a regular Python function. However, it executes more efficiently due to the optimized machine code generated during compilation.</p></li>
<li><p><strong>Benefits</strong>: Using JIT compilation can lead to faster execution times, reduced memory usage, and improved performance, especially for functions involved in numerical computations or machine learning models.</p></li>
</ol>
<div id="789e0ae3-66dd-4a00-b2d4-12d450184120" class="cell" data-tags="[]" data-execution_count="15">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> get_sparse_A(N)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>heat_plot(advance_time_matvecmul_jit, u0, epsilon, A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total computation time: 0.5534884999506176 seconds</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-14-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>0.5534884999506176 seconds in Method 2 compares to 20.457517958944663 seconds in Method 1, the speed increase enomoursly by almost 40 times!</p>
</section>
</section>
<section id="direct-operation-with-numpy" class="level3">
<h3 class="anchored" data-anchor-id="direct-operation-with-numpy">3.3 Direct operation with <code>numpy</code></h3>
<p>We’ll implement a function called advance_time_numpy to advance the solution of the heat equation by one timestep using direct operations with NumPy. Here’s the implementation of the function:</p>
<div id="e75d3333-2e9f-4994-8916-0a8e8a94f80f" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heat_equation <span class="im">import</span> advance_time_numpy</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the source code of the 'advance_time_jax' function</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.getsource(advance_time_numpy))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def advance_time_numpy(u, epsilon):
    # Compute the Laplacian using central differences
    laplacian = (
        np.roll(u, 1, axis=0) +  # Top
        np.roll(u, -1, axis=0) +  # Bottom
        np.roll(u, 1, axis=1) +   # Left
        np.roll(u, -1, axis=1) -   # Right
        4 * u  # Center
    )

    # Update the grid state using the heat equation
    u = u + epsilon * laplacian

    return u
</code></pre>
</div>
</div>
<p><code>np.roll</code> is used to shift the elements of the array u along the specified axes (0 for rows and 1 for columns). By summing the shifted arrays, we effectively compute the Laplacian using central differences without the need for padding the array with zeros.</p>
<p>You can find more info here: https://numpy.org/doc/stable/reference/generated/numpy.roll.html</p>
<p>This function advances the solution of the heat equation by one timestep using NumPy vectorized operations. It computes the Laplacian of the temperature grid using central differences with np.roll, and updates the grid state using the heat equation.</p>
<div id="6c47452a-9711-44f4-b5c5-df390e4c51b4" class="cell" data-tags="[]" data-execution_count="19">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>heat_plot(advance_time_numpy, u0, epsilon)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total computation time: 0.14709462481550872 seconds</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-16-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Now we have:</p>
<pre><code>20.457517958944663 seconds in Method 1
0.5534884999506176 seconds in Method 2
0.14709462481550872 seconds in Method 3</code></pre>
<p>We are getting faster and faster!</p>
</section>
<section id="direction-operation-with-jax" class="level3">
<h3 class="anchored" data-anchor-id="direction-operation-with-jax">3.4 Direction operation with <code>jax</code></h3>
<p>Now, let’s use jax to do the similar using just-in-time compilation. This function advances the simulation of the heat equation by one timestep using JAX. It computes the Laplacian of the temperature grid using central differences, and updates the grid state according to the heat equation. The Laplacian is computed with boundary conditions handled by padding the temperature grid.</p>
<div id="8e255efd-a369-4aac-b91c-dce8eb622864" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heat_equation <span class="im">import</span> advance_time_jax</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the source code of the 'advance_time_jax' function</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.getsource(advance_time_jax))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>@jax.jit
def advance_time_jax(u, epsilon):
    """
    Advances the solution by one timestep using JAX.

    Args:
    u : array_like
        N x N grid state at timestep k.
    epsilon : float
        Stability constant.

    Returns:
    array_like
        N x N grid state at timestep k+1.
    """

    laplacian = (
        jnp.roll(u, 1, axis=0) +  # Top
        jnp.roll(u, -1, axis=0) +  # Bottom
        jnp.roll(u, 1, axis=1) +   # Left
        jnp.roll(u, -1, axis=1) -   # Right
        4 * u  # Center
    )

    # Update the grid state using the heat equation
    u = u + epsilon * laplacian

    return u
</code></pre>
</div>
</div>
<div id="e2864380-3a95-40a9-aeb4-d99d1a980183" class="cell" data-tags="[]" data-execution_count="9">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>heat_plot(advance_time_jax, u0, epsilon)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total computation time: 0.051046375185251236 seconds</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-18-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Well, this is so much faster by using jit!</p>
<p>Now we have:</p>
<pre><code>20.457517958944663 seconds in Method 1
0.5534884999506176 seconds in Method 2
0.14709462481550872 seconds in Method 3
0.051046375185251236 seconds in Method 4</code></pre>
<p>Compare the implementation and performances of the four methods. Last one is the fastest and easy to write.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>