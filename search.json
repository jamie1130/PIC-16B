[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/HW0/index.html",
    "href": "posts/HW0/index.html",
    "title": "HW0",
    "section": "",
    "text": "Hello! This is my HW0.\n\nLoad Palmer Penguins data set\n\nimport plotly.io as pio\npio.renderers.default=\"iframe\"\n\n\nimport pandas as pd\nurl = \"https://raw.githubusercontent.com/pic16b-ucla/24W/main/datasets/palmer_penguins.csv\"\npenguins = pd.read_csv(url)\n\n\npenguins = penguins.dropna(subset = [\"Body Mass (g)\", \"Sex\"])\npenguins[\"Species\"] = penguins[\"Species\"].str.split().str.get(0)\npenguins = penguins[penguins[\"Sex\"] != \".\"]\n\ncols = [\"Species\", \"Island\", \"Sex\", \"Culmen Length (mm)\", \"Culmen Depth (mm)\", \"Flipper Length (mm)\", \"Body Mass (g)\"]\npenguins = penguins[cols]\n\n\npenguins.head()\n\n\n\n\n\n\n\n\nSpecies\nIsland\nSex\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\n\n\n\n\n0\nAdelie\nTorgersen\nMALE\n39.1\n18.7\n181.0\n3750.0\n\n\n1\nAdelie\nTorgersen\nFEMALE\n39.5\n17.4\n186.0\n3800.0\n\n\n2\nAdelie\nTorgersen\nFEMALE\n40.3\n18.0\n195.0\n3250.0\n\n\n4\nAdelie\nTorgersen\nFEMALE\n36.7\n19.3\n193.0\n3450.0\n\n\n5\nAdelie\nTorgersen\nMALE\n39.3\n20.6\n190.0\n3650.0\n\n\n\n\n\n\n\n\n\nHave a general idea of the proportion of each species and the island they inhabit.\n\nimport matplotlib.pyplot as plt\n\nspecies = penguins.Species.value_counts()\nspecies.plot(kind='pie',autopct=\"%.2f%%\")\nplt.title('Percentage Distribution of Penguin Species')\n\nText(0.5, 1.0, 'Percentage Distribution of Penguin Species')\n\n\n\n\n\n\n\n\n\nBased on the pie chart, the Palmer Penguins data set predominantly consists of Adelie penguins, accounting for 43.84%, followed by Gentoo penguins at 35.74%, and finally, Chinstrap penguins at 20.42%.\n\nisland= penguins.Island.value_counts()\nisland.plot(kind='pie',autopct=\"%.2f%%\")\nplt.title('Percentage Distribution of Penguin on Each Island')\n\nText(0.5, 1.0, 'Percentage Distribution of Penguin on Each Island')\n\n\n\n\n\n\n\n\n\nBased on the pie chart, the Palmer Penguins data set indicates that the majority of penguins inhabit Biscoe Island, comprising 48.95%, followed by Dream Island at 36.94%, and finally, Torgersen Island at 14.11%.\n\nimport seaborn as sns\n\n# Set style for seaborn\nsns.set(style=\"whitegrid\")\n\n# Create a figure with three subplots in the same line\nfig, axes = plt.subplots(1, 3, figsize=(15, 5), sharey=True)\n\n# Plot 1: Island = Biscoe\nsns.countplot(x=\"Species\", data=penguins[penguins['Island'] == 'Biscoe'], ax=axes[0])\naxes[0].set_title(\"Biscoe Island\")\n\n# Plot 2: Island = Dream\nsns.countplot(x=\"Species\", data=penguins[penguins['Island'] == 'Dream'], ax=axes[1])\naxes[1].set_title(\"Dream Island\")\n\n# Plot 3: Island = Torgersen\nsns.countplot(x=\"Species\", data=penguins[penguins['Island'] == 'Torgersen'], ax=axes[2])\naxes[2].set_title(\"Torgersen Island\")\n\n# Set common y-label\naxes[0].set_ylabel(\"Count\")\n\nplt.suptitle(\"Distribution of Penguin Species on Different Islands\", y=1.05)\n\n# Adjust layout\nplt.tight_layout()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\nBased on the bar plot illustrating the distribution of each species on each island, Gentoo penguins are the predominant species on Biscoe Island, Chinstrap penguins dominate Dream Island, and Adelie penguins are the major species on Torgersen Island. However, it’s worth noting that Adelie penguins inhabit all three islands, with Dream Island having the highest count of Adelie, even though Torgersen Island exclusively has Adelie penguins.\n\n\nDive deep into the Culmen Length and Culmen Depth relationships\n\nimport plotly\n\nfrom plotly import express as px\n\nfig = px.scatter(data_frame = penguins,\n                 x = \"Culmen Length (mm)\",\n                 y = \"Culmen Depth (mm)\",\n                 color = \"Species\",\n                 hover_name = \"Species\",\n                 hover_data = [\"Island\", \"Sex\"],\n                 size = \"Body Mass (g)\",\n                 size_max = 8,\n                 width = 500,\n                 height = 300,\n                 opacity = 0.5\n                )\n\n#reduce whitespace\nfig.update_layout(margin={\"r\":0, \"t\":0, \"l\":0, \"b\":0})\n# show the plot\nfig.show()\n\n\n\n\nWe now observe a general pattern where Adelie penguins tend to exhibit shorter culmen length but longer culmen depth compared to the other two species. Chinstrap penguins typically fall in the middle for both culmen length and culmen depth when compared to the other two species. On the other hand, Gentoo penguins tend to have greater culmen length and shorter culmen depth than the other two species. In summary, across all species, culmen length tends to be greater than culmen depth.\n\n\nNow, let’s explore the factors that may contribute to the variation in culmen depth and culmen length among different species.\n\n# convert categorical values into numerical values\npenguins_encoded = pd.get_dummies(penguins, columns=[\"Species\", \"Island\", \"Sex\"], drop_first=True)\n\n\npenguins_encoded['Species_Adelie'] = ~penguins_encoded['Species_Chinstrap'] & ~penguins_encoded['Species_Gentoo']\n\n\npenguins_encoded['Island_Biscoe'] =  ~penguins_encoded['Island_Dream'] & ~penguins_encoded['Island_Torgersen']\n\n\npenguins_encoded\n\n\n\n\n\n\n\n\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nSpecies_Chinstrap\nSpecies_Gentoo\nIsland_Dream\nIsland_Torgersen\nSex_MALE\nSpecies_Adelie\nIsland_Biscoe\n\n\n\n\n0\n39.1\n18.7\n181.0\n3750.0\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\nFalse\n\n\n1\n39.5\n17.4\n186.0\n3800.0\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\n\n\n2\n40.3\n18.0\n195.0\n3250.0\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\n\n\n4\n36.7\n19.3\n193.0\n3450.0\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\n\n\n5\n39.3\n20.6\n190.0\n3650.0\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\nFalse\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n338\n47.2\n13.7\n214.0\n4925.0\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\n340\n46.8\n14.3\n215.0\n4850.0\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\n341\n50.4\n15.7\n222.0\n5750.0\nFalse\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\n\n\n342\n45.2\n14.8\n212.0\n5200.0\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\n343\n49.9\n16.1\n213.0\n5400.0\nFalse\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\n\n\n\n\n333 rows × 11 columns\n\n\n\n\n# Compute the correlation matrix\ncorrelation_matrix = penguins_encoded.corr()\n\n# Create a heatmap\nplt.figure(figsize=(10, 8))\nsns.heatmap(correlation_matrix, annot=True, cmap=\"coolwarm\", fmt=\".2f\", linewidths=.5)\n\n# Set plot title\nplt.title(\"Correlation Heatmap\")\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\nBased on the plot, it appears that flipper length has a significant effect on culmen length, with a correlation of 0.65. Following this, body mass shows a correlation of 0.59. This aligns with the earlier visualization, indicating that Adelie tends to have a shorter length with a negative coefficient of -0.84. In contrast, Gentoo tends to have a longer culmen length with a positive coefficient of 0.49. The same trend applies to Chinstrap, with a positive coefficient similar to Gentoo.\nConcerning culmen depth, Adelie tends to have a longer culmen depth with the greatest positive coefficient of 0.53. Dream Island positively affects culmen depth with a coefficient of 0.46, which makes sense as Adelie and Chinstrap occupy the island. Gentoo, on the other hand, exhibits the greatest negative effect on culmen depth, consistent with the fact that Gentoo inhabits Biscoe Island."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/HW1/index.html",
    "href": "posts/HW1/index.html",
    "title": "HW1: Data Wrangling and Visualization of Temperatures",
    "section": "",
    "text": "Hello! This is my HW1.\nimport plotly.io as pio\npio.renderers.default=\"iframe\"\nimport pandas as pd\nimport seaborn as sns \nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport sqlite3\n\nfrom sklearn.linear_model import LinearRegression\nfrom plotly import express as px\nimport calendar\n\nimport plotly.subplots as sp\nimport plotly.graph_objs as go"
  },
  {
    "objectID": "posts/HW1/index.html#create-a-data-base",
    "href": "posts/HW1/index.html#create-a-data-base",
    "title": "HW1: Data Wrangling and Visualization of Temperatures",
    "section": "1. Create a Data Base",
    "text": "1. Create a Data Base\nThe Data Base called HW1.db would contain 3 tables: temperatures, stations, and contries.\nWe will do this by first connect to the data base, then prepare the data frames before write it into the data base. Lastly, check the table information and close the connection.\n\nconn = sqlite3.connect(\"HW1.db\")\n\n\ntemps = pd.read_csv(\"temps.csv\")\n\n\ndef prepare_temp_df(df):\n    df = df.set_index(keys=[\"ID\", \"Year\"])\n    df = df.stack()\n    df = df.reset_index()\n    df = df.rename(columns = {\"level_2\"  : \"Month\" , 0 : \"Temp\"})\n    df[\"Month\"] = df[\"Month\"].str[5:].astype(int)\n    df[\"Temp\"]  = df[\"Temp\"] / 100\n    return(df)\n\n\ntemperature_df = prepare_temp_df(temps)\n\n\ntemperature_df.to_sql(\"temperatures\", conn, if_exists = \"replace\", index = False)\n\n13992662\n\n\n\nstations = pd.read_csv(\"station-metadata.csv\")\n\n\nstations.to_sql(\"stations\", conn, if_exists = \"replace\", index=False)\n\n\ncountries_url = \"https://raw.githubusercontent.com/mysociety/gaze/master/data/fips-10-4-to-iso-country-codes.csv\"\ncountries = pd.read_csv(countries_url)\n\n\ncountries.to_sql(\"countries\", conn, if_exists = \"replace\", index=False)\n\n279\n\n\n\ncursor = conn.cursor()\ncursor.execute(\"SELECT sql FROM sqlite_master WHERE type='table';\")\n\nfor result in cursor.fetchall():\n    print(result[0])\n\nCREATE TABLE \"temperatures\" (\n\"ID\" TEXT,\n  \"Year\" INTEGER,\n  \"Month\" INTEGER,\n  \"Temp\" REAL\n)\nCREATE TABLE \"stations\" (\n\"ID\" TEXT,\n  \"LATITUDE\" REAL,\n  \"LONGITUDE\" REAL,\n  \"STNELEV\" REAL,\n  \"NAME\" TEXT\n)\nCREATE TABLE \"countries\" (\n\"FIPS 10-4\" TEXT,\n  \"ISO 3166\" TEXT,\n  \"Name\" TEXT\n)\n\n\n\nconn.close()"
  },
  {
    "objectID": "posts/HW1/index.html#query-function-query_climate_database",
    "href": "posts/HW1/index.html#query-function-query_climate_database",
    "title": "HW1: Data Wrangling and Visualization of Temperatures",
    "section": "2. Query Function: query_climate_database",
    "text": "2. Query Function: query_climate_database\nThis Query Function located in climate_database.py would extract the information we need from those 3 tables and manipulate it with restrictions.\nWhat this query_climate_database really do is you give it the db file you are gonna use, the country that you want to investigate, the year range of the data you want, and the specific month of temperatures you want.\n\ndb_file, the file name for the database\ncountry, a string giving the name of a country for which data should be returned.\nyear_begin and year_end, two integers giving the earliest and latest years for which should be returned.\nmonth, an integer giving the month of the year for which should be returned.\n\n\nfrom climate_database import query_climate_database\nimport inspect\nprint(inspect.getsource(query_climate_database))\n\ndef query_climate_database(db_file, country, year_begin, year_end, month):\n    with sqlite3.connect(db_file) as conn:\n\n        cmd = \\\n        f\"\"\"\n        SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n        FROM countries C\n        JOIN stations S \n        ON SUBSTR(S.id, 1, 2) = C.\"FIPS 10-4\"\n        JOIN temperatures T\n        ON S.id = T.id\n        WHERE C.name = '{country}'\n        AND (T.year &gt;= {year_begin} AND T.year &lt;= {year_end})\n        AND T.month = {month}\n        \"\"\"\n        df = pd.read_sql_query(cmd, conn)\n    return df\n\n\n\nWe try out the function we imported with parameters country = “India”, year_begin = 1980, year_end = 2020,month = 1. What the function would give us is a data frame with 7 columns: name, latitude, longitude, Name, Year, Month, Temp, so that we would know each station’s temperature of Jan. in India from 1980 to 2020.\nThe result has a shape of 3152*7.\n\nquery_climate_database(db_file = \"HW1.db\",\n                       country = \"India\", \n                       year_begin = 1980, \n                       year_end = 2020,\n                       month = 1)\n\n\n\n\n\n\n\n\nNAME\nLATITUDE\nLONGITUDE\nName\nYear\nMonth\nTemp\n\n\n\n\n0\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1980\n1\n23.48\n\n\n1\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1981\n1\n24.57\n\n\n2\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1982\n1\n24.19\n\n\n3\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1983\n1\n23.51\n\n\n4\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1984\n1\n24.81\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3147\nDARJEELING\n27.050\n88.270\nIndia\n1983\n1\n5.10\n\n\n3148\nDARJEELING\n27.050\n88.270\nIndia\n1986\n1\n6.90\n\n\n3149\nDARJEELING\n27.050\n88.270\nIndia\n1994\n1\n8.10\n\n\n3150\nDARJEELING\n27.050\n88.270\nIndia\n1995\n1\n5.60\n\n\n3151\nDARJEELING\n27.050\n88.270\nIndia\n1997\n1\n5.70\n\n\n\n\n3152 rows × 7 columns"
  },
  {
    "objectID": "posts/HW1/index.html#a-geographic-scatter-function-for-yearly-temperature-increases",
    "href": "posts/HW1/index.html#a-geographic-scatter-function-for-yearly-temperature-increases",
    "title": "HW1: Data Wrangling and Visualization of Temperatures",
    "section": "3. A Geographic Scatter Function for Yearly Temperature Increases",
    "text": "3. A Geographic Scatter Function for Yearly Temperature Increases\n\nHow does the average yearly change in temperature vary within a given country?\nGiven this question, we would like to write a function that would give us the answer vividly.\nThis function temperature_coefficient_plot should accept six explicit arguments, and an undetermined number of keyword arguments.\n\ndb_file, country, year_begin, year_end, and month should be as in the previous part.\nmin_obs, the minimum required number of years of data for any given station. Only data for stations with at least min_obs years worth of data in the specified month should be plotted; the others should be filtered out. df.transform() plus filtering is a good way to achieve this task.\n**kwargs, additional keyword arguments passed to px.scatter_mapbox(). These can be used to control the colormap used, the mapbox style, etc.\n\n\n# convert the numbers of month into names so that we could use in the title\nmonth_names = calendar.month_name\nmonth_number_to_name = {index: month for index, month in enumerate(month_names) if month}\n\n\ndef temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, db_file='HW1.db', **kwargs):\n    # load the database\n    df = query_climate_database(db_file, country, year_begin, year_end, month)\n    \n    # filtering \n    df['num_years'] = df.groupby(['NAME', 'Month'])['Year'].transform('nunique')\n    df = df[df['num_years'] &gt;= min_obs].drop(columns='num_years')\n    \n    # calculate the average yearly change in temperature for each station\n    def coef(data_group):\n        x = data_group[[\"Year\"]]\n        y = data_group[\"Temp\"] \n        LR = LinearRegression()\n        LR.fit(x, y)\n        return LR.coef_[0]\n    \n    coefs = df.groupby([\"NAME\", \"Month\"]).apply(coef)\n    coefs = coefs.reset_index()\n    \n    # merge the station info with yearly temp\n    station_info = df.groupby('NAME', as_index=False).agg({'LATITUDE': 'first', 'LONGITUDE': 'first'})\n    df_merge = pd.merge(coefs, station_info, on='NAME')\n    df_merge = df_merge.rename(columns={0: 'Estimated Yearly Increase(°C)'})\n    df_merge['Estimated Yearly Increase(°C)'] = df_merge['Estimated Yearly Increase(°C)'].round(4)\n    \n    month_name = month_number_to_name[month]\n    # plot\n    fig = px.scatter_mapbox(df_merge,\n                            lat = \"LATITUDE\",\n                            lon = \"LONGITUDE\",\n                            hover_name = \"NAME\",\n                            color = 'Estimated Yearly Increase(°C)',\n                            title = f\"Estimates of Yearly Increase in Temperature in {month_name} for Stations in {country}, Years {year_begin}-{year_end}\",\n                            color_continuous_midpoint = 0,\n                            **kwargs\n                           )\n\n    return fig\n\n\ncolor_map = px.colors.diverging.RdGy_r # choose a colormap\n\nfig = temperature_coefficient_plot(\"India\", 1980, 2020, 1, \n                                   min_obs = 10,\n                                   zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale=color_map)\n\nfig.show()\n\n                                                \n\n\n\nfig.update_layout(margin={\"r\": 0, \"t\": 30, \"l\": 0, \"b\": 30})\n\nfig.show()\n\n                                                \n\n\nAs we can see from the plot Ludhiana, India had a major increase in Jan. temperature from 1980-2020 with a rate of 0.1318. Some other stations near the coast also experienced a increase in Jan. temperature from 1980-2020. The stations inside the country mainly have a decrease in Jan. temperature from 1980-2020."
  },
  {
    "objectID": "posts/HW1/index.html#temperature-changes-in-difference-climate-zone",
    "href": "posts/HW1/index.html#temperature-changes-in-difference-climate-zone",
    "title": "HW1: Data Wrangling and Visualization of Temperatures",
    "section": "4. Temperature Changes in Difference Climate Zone",
    "text": "4. Temperature Changes in Difference Climate Zone\nThere are many different ways to classify climate zones, here is one of them:\nThere are 4 major climate zones.\n\nTropical zone from 0°– 23.5°/ -23.5° - 0°(between the tropics)\nIn the regions between the equator and the tropics (equatorial region), the solar radiation reaches the ground nearly vertically at noontime during almost the entire year. Thereby, it is very warm in these regions. Through high temperatures, more water evaporates and the air is often moist. The resulting frequent and dense cloud cover reduces the effect of solar radiation on ground temperature.\n\n\nSubtropics from 23.5°– 40°/ -40° - -23.5°\nThe subtropics receive the highest radiation in summer, since the Sun’s angle at noon is almost vertical to the Earth, whilst the cloud cover is relatively thin. These regions receive less moisture (see trade winds), what increases the effect of radiation. Therefore, most of the deserts in the world are situated in this zone. In winter, the radiation in these regions decreases significantly, and it can temporarily be very cool and moist.\n\n\nTemperate zone from 40°–60°/ -60° - -40°\nIn the temperate zone, the solar radiation arrives with a smaller angle, and the average temperatures here are much cooler than in the subtropics. The seasons and daylength differ significantly in the course of a year. The climate is characterised by less frequent extremes, a more regular distribution of the precipitation over the year and a longer vegetation period - therefore the name “temperate”.\n\n\nCold zone from 60°–90°/ -90° - -60°\nThe polar areas between 60° latitude and the poles receive less heat through solar radiation, since the Sun has a very flat angle toward the ground. Because of the changes of the Earth axis angle to the Sun, the daylength varies most in this zone. In the summer, polar days occur. Vegetation is only possible during a few months per year and even then is often sparse. The conditions for life in these regions are very hard.\n\n\nLet’s investigate how global warming has affected these four climate zones over the years and across seasons!\nThis query allyear_climate_region_database() would give you Name, NAME, Latitude, Year, Month, Temp if you input the db_file, la_lower, la_upper - db_file - la_lower and la_upper, the latitude range you want to investgate\n\nfrom climate_database import allyear_climate_region_database\nimport inspect\nprint(inspect.getsource(allyear_climate_region_database))\n\ndef allyear_climate_region_database(db_file, la_lower, la_upper):\n    with sqlite3.connect(db_file) as conn:\n\n        cmd = \\\n        f\"\"\"\n        SELECT C.name, S.name, S.latitude, T.year, T.month, T.temp\n        FROM countries C\n        JOIN stations S \n        ON SUBSTR(S.id, 1, 2) = C.\"FIPS 10-4\"\n        JOIN temperatures T\n        ON S.id = T.id\n        WHERE (S.latitude &gt;= {la_lower} AND S.latitude &lt;= {la_upper})\n        \"\"\"\n        df = pd.read_sql_query(cmd, conn)\n    return df\n\n\n\nThe two_season_plot(a, b,season_a, season_b) and four_season_plot(a, b, c, d, season_a, season_b, season_c, season_d) would draw a 2*1 plot or 4*1 plot, coresponds to each season. X axis would be the Year, Y axis would be the Temperatures throughout years.\nThere would 3 lines, the red line is the Max temperature of each month throughout years, the blue line is the Min temperature of each month throughout years, and the black line is the Avg temperature of the year.\n\ndef two_season_plot(a, b,season_a, season_b):\n    # Find the common x-axis range for both DataFrames\n    x_range = [min(min(a['Year']), min(b['Year'])), max(max(a['Year']), max(b['Year']))]\n\n    # Calculate y_range\n    y_range = [min(min(a['MinTemp']), min(b['MinTemp'])), max(max(a['MaxTemp']), max(b['MaxTemp']))]\n\n    # Create subplots with 1 row and 2 columns\n    fig = sp.make_subplots(rows=2, cols=1, subplot_titles=[f'{season_a} Temperature Over Years', f'{season_b} Temperature Over Years'], row_heights=[3, 3])\n\n    # Add line plot for DataFrame 'a' to the first subplot\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['AvgTemp'], mode='lines', name='Avg Temperature', line=dict(color='black')), row=1, col=1)\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['MinTemp'], mode='lines', name='Min Temperature', line=dict(color='rgba(0, 0, 255, 0.3)')), row=1, col=1)\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['MaxTemp'], mode='lines', name='Max Temperature', line=dict(color='rgba(255, 0, 0, 0.3)')), row=1, col=1)\n\n    # Calculate linear regression for DataFrame 'a'\n    a_slope, a_intercept = np.polyfit(a['Year'], a['AvgTemp'], 1)\n    a_regression_line = a_slope * a['Year'] + a_intercept\n\n    # Add linear regression line to the first subplot\n    fig.add_trace(go.Scatter(x=a['Year'], y=a_regression_line, mode='lines', name=f'Regression A: {a_slope:.2f}x + {a_intercept:.2f}', line=dict(color='lightblue')), row=1, col=1)\n\n    # Add line plot for DataFrame 'b' to the second subplot\n    fig.add_trace(go.Scatter(x=b['Year'], y=b['AvgTemp'], mode='lines',name='Avg Temperature', line=dict(color='black'), showlegend=False), row=2, col=1)\n    fig.add_trace(go.Scatter(x=b['Year'], y=b['MinTemp'], mode='lines',name='Min Temperature', line=dict(color='rgba(0, 0, 255, 0.3)'), showlegend=False), row=2, col=1)\n    fig.add_trace(go.Scatter(x=b['Year'], y=b['MaxTemp'], mode='lines',name='Max Temperature', line=dict(color='rgba(255, 0, 0, 0.3)'), showlegend=False), row=2, col=1)\n\n    # Calculate linear regression for DataFrame 'b'\n    b_slope, b_intercept = np.polyfit(b['Year'], b['AvgTemp'], 1)\n    b_regression_line = b_slope * b['Year'] + b_intercept\n\n    # Add linear regression line to the second subplot\n    fig.add_trace(go.Scatter(x=b['Year'], y=b_regression_line, mode='lines', name=f'Regression B: {b_slope:.2f}x + {b_intercept:.2f}', line=dict(color='lightcoral')), row=2, col=1)\n\n    # Set the common x-axis range for both subplots\n    fig.update_xaxes(range=x_range, row=1, col=1)\n    fig.update_xaxes(range=x_range, row=2, col=1)\n\n    # Set the common y-axis range for both subplots\n    fig.update_yaxes(range=y_range, row=1, col=1)\n    fig.update_yaxes(range=y_range, row=2, col=1)\n    \n    fig.update_xaxes(title_text='Year', row=2, col=1)\n    fig.update_yaxes(title_text='Temperature', row=1, col=1)\n    fig.update_yaxes(title_text='Temperature', row=2, col=1)\n\n    # Update layout if needed\n    fig.update_layout(showlegend=True)  # Optional: set showlegend=False if you don't want legends for each subplot\n\n    return fig\n\n\ndef four_season_plot(a, b, c, d, season_a, season_b, season_c, season_d):\n    # Find the common x-axis range for both DataFrames\n    x_range = [min(min(a['Year']), min(b['Year']),min(c['Year']), min(d['Year'])), \n                   max(max(a['Year']), max(b['Year']), max(c['Year']), max(d['Year']))]\n\n    # Calculate y_range\n    y_range = [min(min(a['MinTemp']), min(b['MinTemp']), min(c['MinTemp']), min(d['MinTemp'])), \n                   max(max(a['MaxTemp']), max(b['MaxTemp']), max(c['MaxTemp']), max(d['MaxTemp']))]\n\n    # Create subplots with 1 row and 2 columns\n    fig = sp.make_subplots(rows=4, cols=1, subplot_titles=[f'{season_a} Temperature Over Years', f'{season_b} Temperature Over Years',f'{season_c} Temperature Over Years', f'{season_d} Temperature Over Years'], vertical_spacing=0.1)\n\n    # Add line plot for DataFrame 'a' to the first subplot\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['AvgTemp'], mode='lines', name='Avg Temperature', line=dict(color='black')), row=1, col=1)\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['MinTemp'], mode='lines', name='Min Temperature', line=dict(color='rgba(0, 0, 255, 0.3)')), row=1, col=1)\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['MaxTemp'], mode='lines', name='Max Temperature', line=dict(color='rgba(255, 0, 0, 0.3)')), row=1, col=1)\n\n    # Calculate linear regression for DataFrame 'a'\n    a_slope, a_intercept = np.polyfit(a['Year'], a['AvgTemp'], 1)\n    a_regression_line = a_slope * a['Year'] + a_intercept\n\n    # Add linear regression line to the first subplot\n    fig.add_trace(go.Scatter(x=a['Year'], y=a_regression_line, mode='lines', name=f'Regression 0: {a_slope:.2f}x + {a_intercept:.2f}', line=dict(color='lightblue')), row=1, col=1)\n    \n    i = 2\n    for data in (b,c,d):\n        # Add line plot for DataFrame 'b' to the second subplot\n        fig.add_trace(go.Scatter(x=data['Year'], y=data['AvgTemp'], mode='lines',name='Avg Temperature', line=dict(color='black'), showlegend=False), row=i, col=1)\n        fig.add_trace(go.Scatter(x=data['Year'], y=data['MinTemp'], mode='lines',name='Min Temperature', line=dict(color='rgba(0, 0, 255, 0.3)'), showlegend=False), row=i, col=1)\n        fig.add_trace(go.Scatter(x=data['Year'], y=data['MaxTemp'], mode='lines',name='Max Temperature', line=dict(color='rgba(255, 0, 0, 0.3)'), showlegend=False), row=i, col=1)\n\n        # Calculate linear regression for DataFrame 'b'\n        slope, intercept = np.polyfit(data['Year'], data['AvgTemp'], 1)\n        regression_line = slope * data['Year'] + intercept\n\n        # Add linear regression line to the second subplot\n        fig.add_trace(go.Scatter(x=data['Year'], y=regression_line, mode='lines', name=f\"Regression {i}: {slope:.2f}x + {intercept:.2f}\", line=dict(color='lightcoral')), row=i, col=1)\n        \n        i += 1\n\n    for r in range(1,5):\n        # Set the common x-axis range for both subplots\n        fig.update_xaxes(range=x_range, row=r, col=1)\n\n        # Set the common y-axis range for both subplots\n        fig.update_yaxes(range=y_range, row=r, col=1)\n\n        fig.update_yaxes(title_text='Temperature', row=r, col=1)\n\n    # Update layout if needed\n    fig.update_xaxes(title_text='Year', row=4, col=1)\n    fig.update_layout(showlegend=True)  # Optional: set showlegend=False if you don't want legends for each subplot\n\n    return fig\n\nThe season_plot will notify you the latitude you inputted is locate in which climate zone and the yearly temprature of that zone in different seasons.\n\ndef season_plot(la_lower, la_upper, db_file='HW1.db'):\n    \n    df = allyear_climate_region_database(db_file, la_lower, la_upper)\n    # tropical zone(0-23.5)\n    # northern\n    if la_lower &gt;= 0 and la_upper &lt;= 23.5:       \n        print('This latitude range is in the Northern Tropical Zone and it has only 2 seasons!')\n        \n        #dry(10-3)\n        filter1 = df[df['Month'].isin([10, 1, 2, 3])]\n        # Group by 'Year' and calculate the average temperature for each year\n        avg1 = filter1.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg1.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n        #wet(4-9)\n        filter2 = df[df['Month'].isin([4,5,6,7,8,9])]\n        # Group by 'Year' and calculate the average temperature for each year\n        avg2 = filter2.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg2.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n        \n        a = avg1\n        b = avg2\n        season_a = 'Dry Season'\n        season_b = 'Wet Season'\n        f = two_season_plot(a, b, season_a, season_b)\n        return f\n           \n    # southern\n    if la_lower &gt;= -23.5 and la_upper &lt;= 0:\n        print('This latitude range is in the Southern Tropical Zone and it has only 2 seasons!')\n        a = avg2\n        b = avg1\n        season_a = 'Dry Season'\n        season_b = 'Wet Season'\n        f = two_season_plot(a, b, season_a, season_b)\n        return f\n        \n    # subtropical zone(23.5-40)\n    # northern\n    if la_lower &gt;= 23.5 and la_upper &lt;= 40:\n        print('This latitude range is in the Northern Subtropical Zone and it has only 2 seasons!')\n        \n        # hot summer and mild winter\n        filter1 = df[df['Month'].isin([10, 1, 2, 3])]\n        # Group by 'Year' and calculate the average temperature for each year\n        avg1 = filter1.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg1.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']  \n        #wet(4-9)\n        filter2 = df[df['Month'].isin([4,5,6,7,8,9])]\n        # Group by 'Year' and calculate the average temperature for each year\n        avg2 = filter2.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg2.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']   \n        \n        a = avg1\n        b = avg2\n        season_a = 'Summer Season'\n        season_b = 'Mild Winter Season'\n        f = two_season_plot(a, b, season_a, season_b)\n        return f\n    \n    # southern\n    if la_lower &gt;= -40 and la_upper &lt;= -23.5:\n        print('This latitude range is in the Southern Subtropical Zone and it has only 2 seasons!')\n        a = avg2\n        b = avg1\n        season_a = 'Summer Season'\n        season_b = 'Mild Winter Season'\n        f = two_season_plot(a, b, season_a, season_b)\n        return f\n    \n    #temperate zone(40-60)\n    # northern\n    if la_lower &gt;= 40 and la_upper &lt;= 60:\n        print('This latitude range is in the Northern Temperate Zone and it has 4 seasons!')\n        # spring\n        filter1 = df[df['Month'].isin([3,4,5])]\n        avg1 = filter1.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg1.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']   \n        # summer\n        filter2 = df[df['Month'].isin([6,7,8])]\n        avg2 = filter2.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg2.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']   \n        # autumn\n        filter3 = df[df['Month'].isin([9,10,11])]\n        avg3 = filter3.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg3.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']   \n        # winter\n        filter4 = df[df['Month'].isin([12,1,2])]\n        avg4 = filter4.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg4.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n        \n        a = avg1\n        b = avg2\n        c = avg3\n        d = avg4\n        season_a = 'Spring'\n        season_b = 'Summer'\n        season_c = 'Autumn'\n        season_d = 'Winter'\n        f = four_season_plot(a, b, c, d, season_a, season_b, season_c, season_d)\n        return f\n    # southern\n    if la_lower &gt;= -60 and la_upper &lt;= -40:\n        print('This latitude range is in the Southern Temperate Zone and it has 4 seasons!')\n        a = avg3\n        b = avg4\n        c = avg1\n        d = avg2\n        season_a = 'Spring'\n        season_b = 'Summer'\n        season_c = 'Autumn'\n        season_d = 'Winter'\n        f = four_season_plot(a, b, c, d, season_a, season_b, season_c, season_d)\n        return f\n\n    # cold zone(60-90)\n    # northern\n    if la_lower &gt;= 60 and la_upper &lt;= 90:\n        print('This latitude range is in the Northern Cold Zone and it has 4 seasons!')\n        # spring\n        filter1 = df[df['Month'].isin([3,4,5])]\n        avg1 = filter1.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg1.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']   \n        # summer\n        filter2 = df[df['Month'].isin([6,7,8])]\n        avg2 = filter2.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg2.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']   \n        # autumn\n        filter3 = df[df['Month'].isin([9,10,11])]\n        avg3 = filter3.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg3.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']   \n        # winter\n        filter4 = df[df['Month'].isin([12,1,2])]\n        avg4 = filter4.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index() \n        avg4.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n        \n        a = avg1\n        b = avg2\n        c = avg3\n        d = avg4\n        season_a = 'Spring'\n        season_b = 'Summer'\n        season_c = 'Autumn'\n        season_d = 'Winter'\n        f = four_season_plot(a, b, c, d, season_a, season_b, season_c, season_d)\n        return f   \n\n    warning = 'Your latitude should be inside the range of each zone!'\n    return warning\n\n\nresult = season_plot(60, 90)\n\nThis latitude range is in the Northern Cold Zone and it has 4 seasons!\n\n\n\nresult.update_layout(height=600, width=1000)\nresult.show()\n\n                                                \n\n\nHere you could do the experiment by yourself with different latitude. I plug in 60 and 90, which is in Northern Cold Zone and it has 4 seasons. The overall temperature is low compare to other places and the linear line of average temperature is nearly flat, which indicates a not much of difference among the temperatures over years. Other than that, Spring and Fall share the same distribution, Summer being the overall hottest, and Winter being the overall coldest.\n\n\nDoes the Global Warming effect differently in these 4 climate zones?\nTo answer this question, for each zone, we can plot the yearly average temperature for each zone.\n\ntropical = allyear_climate_region_database('HW1.db', -23.5, 23.5)\n\nsub1 = allyear_climate_region_database('HW1.db', 23.5, 40)\nsub2 = allyear_climate_region_database('HW1.db', -40, -23.5)\nsub = pd.concat([sub1, sub2], ignore_index=True)\n\ntemperate1 = allyear_climate_region_database('HW1.db', 40, 60)\ntemperate2 = allyear_climate_region_database('HW1.db', -60, -40)\ntemperate = pd.concat([temperate1, temperate2], ignore_index=True)\n\ncold = allyear_climate_region_database('HW1.db', 60, 90)\n\n\ntro_avg = tropical.groupby('Year')['Temp'].mean()\nsub_avg = sub.groupby('Year')['Temp'].mean()\ntemperate_avg = temperate.groupby('Year')['Temp'].mean()\ncold_avg = cold.groupby('Year')['Temp'].mean()\n\n\nfig = go.Figure()\n\n# Add trace for tropical dataset\nfig.add_trace(go.Scatter(x=tro_avg.index, y=tro_avg.values, mode='markers', name='Tropical', line=dict(color='blue')))\n\n# Add trace for sub dataset\nfig.add_trace(go.Scatter(x=sub_avg.index, y=sub_avg.values, mode='markers', name='Subtropical', line=dict(color='green')))\n\n# Add trace for temperate dataset\nfig.add_trace(go.Scatter(x=temperate_avg.index, y=temperate_avg.values, mode='markers', name='Temperate', line=dict(color='orange')))\n\n# Add trace for cold dataset\nfig.add_trace(go.Scatter(x=cold_avg.index, y=cold_avg.values, mode='markers', name='Cold', line=dict(color='red')))\n\n# Update layout for better readability\nfig.update_layout(title='Yearly Average Temperature',\n                  xaxis_title='Year',\n                  yaxis_title='Temperature',\n                  legend=dict(title='Dataset'))\n\n# Show the plot\nfig.show()\n\n                                                \n\n\nThe overall Yearly Average Temperature for each climate zone did not change a lot throughout years but with a slight increase for each scatter line especially for the cold and tropical zone. However, from the average temperature, we could barely see the global warming effect. There are more infos that we need to investigate!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jamie’s Blog",
    "section": "",
    "text": "Post With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nJan 11, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 8, 2024\n\n\nJiaxin Luo\n\n\n\n\n\n\n\n\n\n\n\n\nHW1: Data Wrangling and Visualization of Temperatures\n\n\n\n\n\n\nHOMEWORK\n\n\n\n\n\n\n\n\n\nJan 28, 2023\n\n\nJamie\n\n\n\n\n\n\n\n\n\n\n\n\nHW0\n\n\n\n\n\n\nHOMEWORK\n\n\n\n\n\n\n\n\n\nJan 21, 2023\n\n\nJamie\n\n\n\n\n\n\nNo matching items"
  }
]