[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/HW0/index.html",
    "href": "posts/HW0/index.html",
    "title": "Penguin World",
    "section": "",
    "text": "Hello!\nIn this post, I’ll show you how to make a nice visualization of the famous “Palmer Penguins” dataset by using the Pandas, Matplotlib, and Seaborn packages in Python.\n\nimport plotly.io as pio\npio.renderers.default=\"iframe\"\n\n\nLoad The Palmer Penguins Data Set\n\nimport pandas as pd\nurl = \"https://raw.githubusercontent.com/pic16b-ucla/24W/main/datasets/palmer_penguins.csv\"\npenguins = pd.read_csv(url)\n\nPandas is a powerful open-source library in Python used for data manipulation and analysis. It provides easy-to-use data structures and functions to work with structured data. Pandas is commonly used in data preprocessing tasks before feeding data into machine learning models.\n\n# Drop rows with missing values in specific columns\npenguins = penguins.dropna(subset = [\"Body Mass (g)\", \"Sex\"])\n\n# Extract the first word of the \"Species\" column\npenguins[\"Species\"] = penguins[\"Species\"].str.split().str.get(0)\n# Filter out rows where \"Sex\" is not specified\npenguins = penguins[penguins[\"Sex\"] != \".\"]\n\n# Selecting specific columns\ncols = [\"Species\", \"Island\", \"Sex\", \"Culmen Length (mm)\", \"Culmen Depth (mm)\", \"Flipper Length (mm)\", \"Body Mass (g)\"]\npenguins = penguins[cols]\n\n\npenguins.head()\n\n\n\n\n\n\n\n\nSpecies\nIsland\nSex\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\n\n\n\n\n0\nAdelie\nTorgersen\nMALE\n39.1\n18.7\n181.0\n3750.0\n\n\n1\nAdelie\nTorgersen\nFEMALE\n39.5\n17.4\n186.0\n3800.0\n\n\n2\nAdelie\nTorgersen\nFEMALE\n40.3\n18.0\n195.0\n3250.0\n\n\n4\nAdelie\nTorgersen\nFEMALE\n36.7\n19.3\n193.0\n3450.0\n\n\n5\nAdelie\nTorgersen\nMALE\n39.3\n20.6\n190.0\n3650.0\n\n\n\n\n\n\n\n\n\nHave a general idea of the proportion of each species and the island they inhabit.\nMatplotlib is a widely used Python library for creating static, interactive, and animated visualizations in Python. It provides a MATLAB-like interface and can generate plots, histograms, power spectra, bar charts, error charts, scatterplots, etc.\n\nimport matplotlib.pyplot as plt\n\n# Count the occurrences of each species\nspecies = penguins.Species.value_counts()\n\n# Plotting the pie chart\nspecies.plot(kind='pie', autopct=\"%.2f%%\")\nplt.title('Percentage Distribution of Penguin Species')\n\n# Display the pie chart\nplt.show()\n\nText(0.5, 1.0, 'Percentage Distribution of Penguin Species')\n\n\n\n\n\n\n\n\n\nBased on the pie chart, the Palmer Penguins data set predominantly consists of Adelie penguins, accounting for 43.84%, followed by Gentoo penguins at 35.74%, and finally, Chinstrap penguins at 20.42%.\n\n# Count the occurrences of penguins on each island\nisland = penguins.Island.value_counts()\n\n# Plotting the pie chart\nisland.plot(kind='pie', autopct=\"%.2f%%\")\nplt.title('Percentage Distribution of Penguins on Each Island')\n\n# Display the pie chart\nplt.show()\n\nText(0.5, 1.0, 'Percentage Distribution of Penguin on Each Island')\n\n\n\n\n\n\n\n\n\nBased on the pie chart, the Palmer Penguins data set indicates that the majority of penguins inhabit Biscoe Island, comprising 48.95%, followed by Dream Island at 36.94%, and finally, Torgersen Island at 14.11%.\n\nimport seaborn as sns\n\n# Set style for seaborn\nsns.set(style=\"whitegrid\")\n\n# Create a figure with three subplots in the same line\nfig, axes = plt.subplots(1, 3, figsize=(15, 5), sharey=True)\n\n# Plot 1: Island = Biscoe\nsns.countplot(x=\"Species\", data=penguins[penguins['Island'] == 'Biscoe'], ax=axes[0])\naxes[0].set_title(\"Biscoe Island\")\n\n# Plot 2: Island = Dream\nsns.countplot(x=\"Species\", data=penguins[penguins['Island'] == 'Dream'], ax=axes[1])\naxes[1].set_title(\"Dream Island\")\n\n# Plot 3: Island = Torgersen\nsns.countplot(x=\"Species\", data=penguins[penguins['Island'] == 'Torgersen'], ax=axes[2])\naxes[2].set_title(\"Torgersen Island\")\n\n# Set common y-label\naxes[0].set_ylabel(\"Count\")\n\nplt.suptitle(\"Distribution of Penguin Species on Different Islands\", y=1.05)\n\n# Adjust layout\nplt.tight_layout()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\nBased on the bar plot illustrating the distribution of each species on each island, Gentoo penguins are the predominant species on Biscoe Island, Chinstrap penguins dominate Dream Island, and Adelie penguins are the major species on Torgersen Island. However, it’s worth noting that Adelie penguins inhabit all three islands, with Dream Island having the highest count of Adelie, even though Torgersen Island exclusively has Adelie penguins.\n\n\nDive deep into the Culmen Length and Culmen Depth relationships\nPlotly Express is a Python library that provides an easy-to-use interface for creating interactive visualizations. It is built on top of Plotly, a JavaScript library for creating interactive plots. Plotly Express offers a wide range of chart types and customization options.\n\npx.scatter(): This function creates a scatter plot using Plotly Express. We specify the DataFrame penguins and map the columns “Culmen Length (mm)” to the x-axis and “Culmen Depth (mm)” to the y-axis.\ncolor=\"Species\": This parameter colors the points based on the species of the penguins.\nhover_name=\"Species\": This parameter determines what appears when hovering over each point. Here, we display the species name.\nhover_data=[\"Island\", \"Sex\"]: This parameter adds additional information to be displayed when hovering over each point. We include the island and sex of the penguins.\nsize=\"Body Mass (g)\": This parameter sizes the points based on the body mass of the penguins.\nsize_max=8: This parameter sets the maximum size of the points.\nwidth=500, height=300: These parameters set the width and height of the plot.\nopacity=0.5: This parameter sets the opacity of the points to 0.5, making them slightly transparent.\n\n\nimport plotly\n\nfrom plotly import express as px\n\nfig = px.scatter(data_frame = penguins,\n                 x = \"Culmen Length (mm)\",\n                 y = \"Culmen Depth (mm)\",\n                 color = \"Species\",\n                 hover_name = \"Species\",\n                 hover_data = [\"Island\", \"Sex\"],\n                 size = \"Body Mass (g)\",\n                 size_max = 8,\n                 width = 500,\n                 height = 300,\n                 opacity = 0.5\n                )\n\n#reduce whitespace\nfig.update_layout(margin={\"r\":0, \"t\":0, \"l\":0, \"b\":0})\n# show the plot\nfig.show()\n\n\n\n\nWe now observe a general pattern where Adelie penguins tend to exhibit shorter culmen length but longer culmen depth compared to the other two species. Chinstrap penguins typically fall in the middle for both culmen length and culmen depth when compared to the other two species. On the other hand, Gentoo penguins tend to have greater culmen length and shorter culmen depth than the other two species. In summary, across all species, culmen length tends to be greater than culmen depth.\n\n\nNow, let’s explore the factors that may contribute to the variation in culmen depth and culmen length among different species.\nFirst let’s do some data preprocessing:\nThe line of code penguins_encoded = pd.get_dummies(penguins, columns=[\"Species\", \"Island\", \"Sex\"], drop_first=True) is used to convert categorical values into numerical values through a process called one-hot encoding.\nExplanation:\n\nCategorical Variables: Categorical variables are variables that can take on a limited, and usually fixed, number of possible values. In the DataFrame penguins, the columns “Species”, “Island”, and “Sex” are categorical variables because they represent categories rather than numerical quantities.\nOne-Hot Encoding: One-hot encoding is a technique used to convert categorical variables into a numerical format that can be provided as input to machine learning algorithms. In this encoding scheme, each category is represented as a binary vector, where each element of the vector corresponds to one category. The element representing the category of a particular observation is set to 1, while all other elements are set to 0.\npd.get_dummies() Function: The pd.get_dummies() function provided by the Pandas library is used to perform one-hot encoding. It creates a new DataFrame where each categorical variable specified in the columns parameter is converted into one-hot encoded columns.\ndrop_first=True: The drop_first parameter is set to True to avoid multicollinearity in the dataset. When drop_first=True, the first category for each variable is dropped after encoding, leaving only n-1 binary columns for n categories. This prevents redundancy in the data, as the dropped category can be inferred from the other binary columns. It also helps to avoid issues such as the “dummy variable trap” in regression analysis.\nOutput: After executing this line of code, penguins_encoded will contain the original columns from penguins, along with new binary columns representing the one-hot encoded categorical variables. Each binary column corresponds to a unique category within the original categorical variable. The dataset is now in a format suitable for many machine learning algorithms that require numerical input.\n\n\n# convert categorical values into numerical values\npenguins_encoded = pd.get_dummies(penguins, columns=[\"Species\", \"Island\", \"Sex\"], drop_first=True)\n\nSince we want to find out each variable’s relation with the Culmen Length and Culmen Depth, the following code will add 2 extra columns for Species_Adelie and Island_Biscoe since they would not be included in the data frame due to get_dummies would neglact these 2 columns and replace it with other columns being False and False.\n\npenguins_encoded['Species_Adelie'] = ~penguins_encoded['Species_Chinstrap'] & ~penguins_encoded['Species_Gentoo']\n\n\npenguins_encoded['Island_Biscoe'] =  ~penguins_encoded['Island_Dream'] & ~penguins_encoded['Island_Torgersen']\n\n\npenguins_encoded\n\n\n\n\n\n\n\n\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nSpecies_Chinstrap\nSpecies_Gentoo\nIsland_Dream\nIsland_Torgersen\nSex_MALE\nSpecies_Adelie\nIsland_Biscoe\n\n\n\n\n0\n39.1\n18.7\n181.0\n3750.0\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\nFalse\n\n\n1\n39.5\n17.4\n186.0\n3800.0\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\n\n\n2\n40.3\n18.0\n195.0\n3250.0\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\n\n\n4\n36.7\n19.3\n193.0\n3450.0\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\n\n\n5\n39.3\n20.6\n190.0\n3650.0\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\nFalse\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n338\n47.2\n13.7\n214.0\n4925.0\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\n340\n46.8\n14.3\n215.0\n4850.0\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\n341\n50.4\n15.7\n222.0\n5750.0\nFalse\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\n\n\n342\n45.2\n14.8\n212.0\n5200.0\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\n343\n49.9\n16.1\n213.0\n5400.0\nFalse\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\n\n\n\n\n333 rows × 11 columns\n\n\n\n\n# Compute the correlation matrix\ncorrelation_matrix = penguins_encoded.corr()\n\n# Create a heatmap\nplt.figure(figsize=(10, 8))\nsns.heatmap(correlation_matrix, annot=True, cmap=\"coolwarm\", fmt=\".2f\", linewidths=.5)\n\n# Set plot title\nplt.title(\"Correlation Heatmap\")\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\nBased on the plot, it appears that flipper length has a significant effect on culmen length, with a correlation of 0.65. Following this, body mass shows a correlation of 0.59. This aligns with the earlier visualization, indicating that Adelie tends to have a shorter length with a negative coefficient of -0.84. In contrast, Gentoo tends to have a longer culmen length with a positive coefficient of 0.49. The same trend applies to Chinstrap, with a positive coefficient similar to Gentoo.\nConcerning culmen depth, Adelie tends to have a longer culmen depth with the greatest positive coefficient of 0.53. Dream Island positively affects culmen depth with a coefficient of 0.46, which makes sense as Adelie and Chinstrap occupy the island. Gentoo, on the other hand, exhibits the greatest negative effect on culmen depth, consistent with the fact that Gentoo inhabits Biscoe Island."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/HW1/index.html",
    "href": "posts/HW1/index.html",
    "title": "Global Warming: Data Wrangling and Visualization",
    "section": "",
    "text": "Hello!"
  },
  {
    "objectID": "posts/HW1/index.html#intro",
    "href": "posts/HW1/index.html#intro",
    "title": "Global Warming: Data Wrangling and Visualization",
    "section": "Intro",
    "text": "Intro\nIn this blog, we will develop interactive tools that offer an engaging exploration of the impact of global warming on temperatures worldwide. Moreover, I’ll guide you through the process, assuming you possess fundamental Python skills. The primary tools employed include Matplotlib and Seaborn, with a significant focus on Plotly for creating interactive graphics. Additionally, we’ll utilize Pandas and NumPy for efficient dataframe manipulation and SQLite3 for establishing the database.\nThe data set that we are going to use are:\n\ntemperatures(NOAA-GHCN data): temps.csv from the class\nstations: station-metadata.csv fromt the class\ncontries: https://raw.githubusercontent.com/mysociety/gaze/master/data/fips-10-4-to-iso-country-codes.csv\n\nLet’s get start it!!"
  },
  {
    "objectID": "posts/HW1/index.html#import-libraries-1",
    "href": "posts/HW1/index.html#import-libraries-1",
    "title": "Global Warming: Data Wrangling and Visualization",
    "section": "1. Import Libraries",
    "text": "1. Import Libraries\n\n# Set the default Plotly renderer to \"iframe\"\nimport plotly.io as pio\npio.renderers.default = \"iframe\"\n\n\nimport pandas as pd\nimport seaborn as sns \nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport sqlite3\n\nfrom sklearn.linear_model import LinearRegression\nfrom plotly import express as px\nimport calendar\n\nimport plotly.subplots as sp\nimport plotly.graph_objs as go"
  },
  {
    "objectID": "posts/HW1/index.html#create-data-base-1",
    "href": "posts/HW1/index.html#create-data-base-1",
    "title": "Global Warming: Data Wrangling and Visualization",
    "section": "2. Create Data Base",
    "text": "2. Create Data Base\nThe Data Base called HW1.db would contain 3 tables: temperatures, stations, and contries.\nWe will do this by : - First connect to the data base - Then prepare the data frames before write it into the data base. - Lastly, check the table information and close the connection.\n\n# Connect to the data base HW1.db\n\nconn = sqlite3.connect(\"HW1.db\")\n\n\nTable1: temperatures\n\ntemps = pd.read_csv(\"temps.csv\")\n\n\ndef prepare_temp_df(df):\n    \"\"\"\n    Preprocesses a DataFrame containing temperature data.\n\n    Parameters:\n    - df (pd.DataFrame): Input DataFrame containing temperature information.\n\n    Returns:\n    - pd.DataFrame: Processed DataFrame with columns: 'ID', 'Year', 'Month', 'Temp'.\n      'Month' is extracted from the original DataFrame, and 'Temp' is normalized to degrees Celsius.\n\n    Steps:\n    1. Set the multi-index with keys 'ID' and 'Year'.\n    2. Stack the DataFrame to transform columns into rows.\n    3. Reset the index to create a new default integer index.\n    4. Rename columns to 'Month' and 'Temp'.\n    5. Extract the numeric month from the 'Month' column.\n    6. Normalize the 'Temp' column by dividing by 100.\n    \"\"\"\n    df = df.set_index(keys=[\"ID\", \"Year\"])\n    df = df.stack()\n    df = df.reset_index()\n    df = df.rename(columns={\"level_2\": \"Month\", 0: \"Temp\"})\n    df[\"Month\"] = df[\"Month\"].str[5:].astype(int)\n    df[\"Temp\"] = df[\"Temp\"] / 100\n    return df\n\n\ntemperature_df = prepare_temp_df(temps)\n\n\n# Write the DataFrame 'temperature_df' to an SQLite database table named 'temperatures'\n# using the connection object 'conn'. If the table already exists, replace it.\n# Set the 'index' parameter to False to avoid writing the DataFrame index as a separate column.\n\ntemperature_df.to_sql(\"temperatures\", conn, if_exists = \"replace\", index = False)\n\n13992662\n\n\n\n\nTable2: stations\n\nstations = pd.read_csv(\"station-metadata.csv\")\n\n\n# Write the DataFrame 'stations' to an SQLite database table named 'stations'\n# using the connection object 'conn'. If the table already exists, replace it.\n# Set the 'index' parameter to False to avoid writing the DataFrame index as a separate column.\n\nstations.to_sql(\"stations\", conn, if_exists=\"replace\", index=False)\n\n\n\nTable3: countries\n\n# Read the CSV data from the URL 'countries_url' into a DataFrame 'countries'\ncountries_url = \"https://raw.githubusercontent.com/mysociety/gaze/master/data/fips-10-4-to-iso-country-codes.csv\"\ncountries = pd.read_csv(countries_url)\n\n# Write the DataFrame 'countries' to an SQLite database table named 'countries'\n# using the connection object 'conn'. If the table already exists, replace it.\n# Set the 'index' parameter to False to avoid writing the DataFrame index as a separate column.\ncountries.to_sql(\"countries\", conn, if_exists=\"replace\", index=False)\n\n279\n\n\n\n# Create a cursor object from the SQLite connection\ncursor = conn.cursor()\n\n# Execute a SQL query to retrieve the CREATE TABLE statements for all tables in the database\ncursor.execute(\"SELECT sql FROM sqlite_master WHERE type='table';\")\n\n# Fetch and print the CREATE TABLE statements for each table\nfor result in cursor.fetchall():\n    print(result[0])\n\nCREATE TABLE \"temperatures\" (\n\"ID\" TEXT,\n  \"Year\" INTEGER,\n  \"Month\" INTEGER,\n  \"Temp\" REAL\n)\nCREATE TABLE \"stations\" (\n\"ID\" TEXT,\n  \"LATITUDE\" REAL,\n  \"LONGITUDE\" REAL,\n  \"STNELEV\" REAL,\n  \"NAME\" TEXT\n)\nCREATE TABLE \"countries\" (\n\"FIPS 10-4\" TEXT,\n  \"ISO 3166\" TEXT,\n  \"Name\" TEXT\n)\n\n\nHere we checked the names of tables, columns of tables, and the storage type of each column.\n\n# Close the connection\nconn.close()"
  },
  {
    "objectID": "posts/HW1/index.html#query-function-query_climate_database-1",
    "href": "posts/HW1/index.html#query-function-query_climate_database-1",
    "title": "Global Warming: Data Wrangling and Visualization",
    "section": "3. Query Function: query_climate_database",
    "text": "3. Query Function: query_climate_database\nThis Query Function located in climate_database.py would extract the information we need from those 3 tables and manipulate it with restrictions.\nWhat this query_climate_database really do is you give it the db file you are gonna use, the country that you want to investigate, the year range of the data you want, and the specific month of temperatures you want.\n\ndb_file, the file name for the database\ncountry, a string giving the name of a country for which data should be returned.\nyear_begin and year_end, two integers giving the earliest and latest years for which should be returned.\nmonth, an integer giving the month of the year for which should be returned.\n\n\nfrom climate_database import query_climate_database\nimport inspect\n\n# Print the source code of the 'query_climate_database' function\nprint(inspect.getsource(query_climate_database))\n\ndef query_climate_database(db_file, country, year_begin, year_end, month):\n    with sqlite3.connect(db_file) as conn:\n\n        cmd = \\\n        f\"\"\"\n        SELECT S.name, S.latitude, S.longitude, C.name as Country, T.year, T.month, T.temp\n        FROM countries C\n        JOIN stations S \n        ON SUBSTR(S.id, 1, 2) = C.\"FIPS 10-4\"\n        JOIN temperatures T\n        ON S.id = T.id\n        WHERE C.name = '{country}'\n        AND (T.year &gt;= {year_begin} AND T.year &lt;= {year_end})\n        AND T.month = {month}\n        \"\"\"\n        df = pd.read_sql_query(cmd, conn)\n    return df\n\n\n\nWe try out the function we imported with parameters country = “India”, year_begin = 1980, year_end = 2020,month = 1. What the function would give us is a data frame with 7 columns: name, latitude, longitude, Name, Year, Month, Temp, so that we would know each station’s temperature of Jan. in India from 1980 to 2020.\nThe result has a shape of 3152*7.\n\n# test case\nquery_climate_database(db_file = \"HW1.db\",\n                       country = \"India\", \n                       year_begin = 1980, \n                       year_end = 2020,\n                       month = 1)\n\n\n\n\n\n\n\n\nNAME\nLATITUDE\nLONGITUDE\nName\nYear\nMonth\nTemp\n\n\n\n\n0\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1980\n1\n23.48\n\n\n1\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1981\n1\n24.57\n\n\n2\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1982\n1\n24.19\n\n\n3\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1983\n1\n23.51\n\n\n4\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1984\n1\n24.81\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3147\nDARJEELING\n27.050\n88.270\nIndia\n1983\n1\n5.10\n\n\n3148\nDARJEELING\n27.050\n88.270\nIndia\n1986\n1\n6.90\n\n\n3149\nDARJEELING\n27.050\n88.270\nIndia\n1994\n1\n8.10\n\n\n3150\nDARJEELING\n27.050\n88.270\nIndia\n1995\n1\n5.60\n\n\n3151\nDARJEELING\n27.050\n88.270\nIndia\n1997\n1\n5.70\n\n\n\n\n3152 rows × 7 columns"
  },
  {
    "objectID": "posts/HW1/index.html#a-geographic-scatter-function-for-yearly-temperature-increases-1",
    "href": "posts/HW1/index.html#a-geographic-scatter-function-for-yearly-temperature-increases-1",
    "title": "Global Warming: Data Wrangling and Visualization",
    "section": "4. A Geographic Scatter Function for Yearly Temperature Increases",
    "text": "4. A Geographic Scatter Function for Yearly Temperature Increases\n\nHow does the average yearly change in temperature vary within a given country?\nGiven this question, we would like to write a function that would give us the answer vividly.\nThis function temperature_coefficient_plot should accept six explicit arguments, and an undetermined number of keyword arguments.\n\ndb_file, country, year_begin, year_end, and month should be as in the previous part.\nmin_obs, the minimum required number of years of data for any given station. Only data for stations with at least min_obs years worth of data in the specified month should be plotted; the others should be filtered out. df.transform() plus filtering is a good way to achieve this task.\n**kwargs, additional keyword arguments passed to px.scatter_mapbox(). These can be used to control the colormap used, the mapbox style, etc.\n\n\n# convert the numbers of month into names so that we could use in the title\nmonth_names = calendar.month_name\nmonth_number_to_name = {index: month for index, month in enumerate(month_names) if month}\n\n\ndef temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, db_file='HW1.db', **kwargs):\n    \"\"\"\n    Generate a scatter plot on a map showing the estimated yearly increase in temperature for weather stations in a specified country and month.\n\n    Parameters:\n    - country (str): Country name.\n    - year_begin (int): Starting year for data retrieval.\n    - year_end (int): Ending year for data retrieval.\n    - month (int): Numeric representation of the month for data retrieval(1-12).\n    - min_obs (int): Minimum number of years of observation required for a station to be included.\n    - db_file (str, optional): Database file path. Default is 'HW1.db'.\n    - **kwargs: Additional keyword arguments to be passed to Plotly Express scatter_mapbox.\n\n    Returns:\n    - plotly.graph_objs.Figure: Scatter plot on a map.\n\n    Note:\n    - Requires the 'query_climate_database' function from the 'climate_database' module.\n\n    Example:\n    ```python\n    fig = temperature_coefficient_plot('USA', 2000, 2020, 7, 10)\n    fig.show()\n    ```\n    \"\"\"\n    # load the database\n    df = query_climate_database(db_file, country, year_begin, year_end, month)\n    \n    # filtering \n    df['num_years'] = df.groupby(['NAME', 'Month'])['Year'].transform('nunique')\n    df = df[df['num_years'] &gt;= min_obs].drop(columns='num_years')\n    \n    # calculate the average yearly change in temperature for each station\n    def coef(data_group):\n        x = data_group[[\"Year\"]]\n        y = data_group[\"Temp\"] \n        LR = LinearRegression()\n        LR.fit(x, y)\n        return LR.coef_[0]\n    \n    coefs = df.groupby([\"NAME\", \"Month\"]).apply(coef)\n    coefs = coefs.reset_index()\n    \n    # merge the station info with yearly temp\n    station_info = df.groupby('NAME', as_index=False).agg({'LATITUDE': 'first', 'LONGITUDE': 'first'})\n    df_merge = pd.merge(coefs, station_info, on='NAME')\n    df_merge = df_merge.rename(columns={0: 'Estimated Yearly Increase(°C)'})\n    df_merge['Estimated Yearly Increase(°C)'] = df_merge['Estimated Yearly Increase(°C)'].round(4)\n    \n    month_name = month_number_to_name[month]\n    # plot\n    fig = px.scatter_mapbox(df_merge,\n                            lat=\"LATITUDE\",\n                            lon=\"LONGITUDE\",\n                            hover_name=\"NAME\",\n                            color='Estimated Yearly Increase(°C)',\n                            title=f\"Estimates of Yearly Increase in Temperature in {month_name} for Stations in {country}, Years {year_begin}-{year_end}\",\n                            color_continuous_midpoint=0,\n                            **kwargs\n                           )\n\n    return fig\n\n\ncolor_map = px.colors.diverging.RdGy_r # choose a colormap\n\nfig = temperature_coefficient_plot(\"India\", 1980, 2020, 1, \n                                   min_obs = 10,\n                                   zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale=color_map)\n\n# if you want to make the graph larger:\n# fig.update_layout(margin={\"r\": 0, \"t\": 30, \"l\": 0, \"b\": 30})\n\nfig.show()\n\n\n\n\nAs we can see from the plot Ludhiana, India had a major increase in Jan. temperature from 1980-2020 with a rate of 0.1318. Some other stations near the coast also experienced a increase in Jan. temperature from 1980-2020. The stations inside the country mainly have a decrease in Jan. temperature from 1980-2020.\n\ncolor_map = px.colors.diverging.RdBu_r # choose a colormap\n\nfig = temperature_coefficient_plot('Russia', 1980, 2010, 6, \n                                   min_obs = 12,\n                                   zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale=color_map)\n\n# if you want to make the graph larger:\n# fig.update_layout(margin={\"r\": 0, \"t\": 30, \"l\": 0, \"b\": 30})\n\nfig.show()\n\n\n\n\nFrom the plot, it’s evident that Amguema, Russia experienced a significant increase in June temperature from 1980 to 2020, with a rate of 0.286. Most cities are located in the southern regions due to warmer climates, while city distribution in Russia is more dispersed in the north due to colder temperatures. It’s notable that the right-hand side of the plot shows mostly increasing temperatures, with western cities experiencing a slight decrease, albeit minimal as indicated by the lighter color close to white. Conversely, eastern cities exhibit more pronounced changes in temperature, indicated by darker colors. We can potentially observe the effects of global warming near the North Pole, as the upper region of Russia, which is close to the Arctic, shows an overall increase in temperature."
  },
  {
    "objectID": "posts/HW1/index.html#temperature-changes-in-difference-climate-zone",
    "href": "posts/HW1/index.html#temperature-changes-in-difference-climate-zone",
    "title": "Global Warming: Data Wrangling and Visualization",
    "section": "5. Temperature Changes in Difference Climate Zone",
    "text": "5. Temperature Changes in Difference Climate Zone\n\nBackground\nThere are many different ways to classify climate zones, here is one of them:\nThere are 4 major climate zones.\n\nTropical zone from 0°– 23.5°/ -23.5° - 0°(between the tropics)\nIn the regions between the equator and the tropics (equatorial region), the solar radiation reaches the ground nearly vertically at noontime during almost the entire year. Thereby, it is very warm in these regions. Through high temperatures, more water evaporates and the air is often moist. The resulting frequent and dense cloud cover reduces the effect of solar radiation on ground temperature.\n\n\nSubtropics from 23.5°– 40°/ -40° - -23.5°\nThe subtropics receive the highest radiation in summer, since the Sun’s angle at noon is almost vertical to the Earth, whilst the cloud cover is relatively thin. These regions receive less moisture (see trade winds), what increases the effect of radiation. Therefore, most of the deserts in the world are situated in this zone. In winter, the radiation in these regions decreases significantly, and it can temporarily be very cool and moist.\n\n\nTemperate zone from 40°–60°/ -60° - -40°\nIn the temperate zone, the solar radiation arrives with a smaller angle, and the average temperatures here are much cooler than in the subtropics. The seasons and daylength differ significantly in the course of a year. The climate is characterised by less frequent extremes, a more regular distribution of the precipitation over the year and a longer vegetation period - therefore the name “temperate”.\n\n\nCold zone from 60°–90°/ -90° - -60°\nThe polar areas between 60° latitude and the poles receive less heat through solar radiation, since the Sun has a very flat angle toward the ground. Because of the changes of the Earth axis angle to the Sun, the daylength varies most in this zone. In the summer, polar days occur. Vegetation is only possible during a few months per year and even then is often sparse. The conditions for life in these regions are very hard.\n\n\n\nHow has global warming impacted the four climate zones throughout the years and across different seasons?\nThis query allyear_climate_region_database() would give you Name, NAME, Latitude, Year, Month, Temp if you input the db_file, la_lower, la_upper - db_file - la_lower and la_upper, the latitude range you want to investgate\n\nfrom climate_database import allyear_climate_region_database\nimport inspect\n\n# Print the source code of the 'allyear_climate_region_database' function\nprint(inspect.getsource(allyear_climate_region_database))\n\ndef allyear_climate_region_database(db_file, la_lower, la_upper):\n    with sqlite3.connect(db_file) as conn:\n\n        cmd = \\\n        f\"\"\"\n        SELECT C.name, S.name, S.latitude, T.year, T.month, T.temp\n        FROM countries C\n        JOIN stations S \n        ON SUBSTR(S.id, 1, 2) = C.\"FIPS 10-4\"\n        JOIN temperatures T\n        ON S.id = T.id\n        WHERE (S.latitude &gt;= {la_lower} AND S.latitude &lt;= {la_upper})\n        \"\"\"\n        df = pd.read_sql_query(cmd, conn)\n    return df\n\n\n\nThe two_season_plot(a, b,season_a, season_b) and four_season_plot(a, b, c, d, season_a, season_b, season_c, season_d) would draw a 2*1 plot or 4*1 plot, coresponds to each season. X axis would be the Year, Y axis would be the Temperatures throughout years.\nThere would 3 lines, the red line is the Max temperature of each month throughout years, the blue line is the Min temperature of each month throughout years, and the black line is the Avg temperature of the year.\n\ndef two_season_plot(a, b, season_a, season_b):\n    \"\"\"\n    Generate a side-by-side plot comparing temperature trends for two different seasons over the years.\n\n    Parameters:\n    - a (pd.DataFrame): DataFrame for the first season's temperature data.\n    - b (pd.DataFrame): DataFrame for the second season's temperature data.\n    - season_a (str): Name or identifier for the first season.\n    - season_b (str): Name or identifier for the second season.\n\n    Returns:\n    - plotly.graph_objs.Figure: Side-by-side line plots with linear regression lines for both seasons.\n\n    Example:\n    ```python\n    fig = two_season_plot(df_season_spring, df_season_fall, 'Spring', 'Fall')\n    fig.show()\n    ```\n    \"\"\"\n    # Find the common x-axis range for both DataFrames\n    x_range = [min(min(a['Year']), min(b['Year'])), max(max(a['Year']), max(b['Year']))]\n\n    # Calculate y_range\n    y_range = [min(min(a['MinTemp']), min(b['MinTemp'])), max(max(a['MaxTemp']), max(b['MaxTemp']))]\n\n    # Create subplots with 1 row and 2 columns\n    fig = sp.make_subplots(rows=2, cols=1, subplot_titles=[f'{season_a} Temperature Over Years', f'{season_b} Temperature Over Years'], row_heights=[3, 3])\n\n    # Add line plot for DataFrame 'a' to the first subplot\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['AvgTemp'], mode='lines', name='Avg Temperature', line=dict(color='black')), row=1, col=1)\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['MinTemp'], mode='lines', name='Min Temperature', line=dict(color='rgba(0, 0, 255, 0.3)')), row=1, col=1)\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['MaxTemp'], mode='lines', name='Max Temperature', line=dict(color='rgba(255, 0, 0, 0.3)')), row=1, col=1)\n\n    # Calculate linear regression for DataFrame 'a'\n    a_slope, a_intercept = np.polyfit(a['Year'], a['AvgTemp'], 1)\n    a_regression_line = a_slope * a['Year'] + a_intercept\n\n    # Add linear regression line to the first subplot\n    fig.add_trace(go.Scatter(x=a['Year'], y=a_regression_line, mode='lines', name=f'Regression A: {a_slope:.2f}x + {a_intercept:.2f}', line=dict(color='lightblue')), row=1, col=1)\n\n    # Add line plot for DataFrame 'b' to the second subplot\n    fig.add_trace(go.Scatter(x=b['Year'], y=b['AvgTemp'], mode='lines',name='Avg Temperature', line=dict(color='black'), showlegend=False), row=2, col=1)\n    fig.add_trace(go.Scatter(x=b['Year'], y=b['MinTemp'], mode='lines',name='Min Temperature', line=dict(color='rgba(0, 0, 255, 0.3)'), showlegend=False), row=2, col=1)\n    fig.add_trace(go.Scatter(x=b['Year'], y=b['MaxTemp'], mode='lines',name='Max Temperature', line=dict(color='rgba(255, 0, 0, 0.3)'), showlegend=False), row=2, col=1)\n\n    # Calculate linear regression for DataFrame 'b'\n    b_slope, b_intercept = np.polyfit(b['Year'], b['AvgTemp'], 1)\n    b_regression_line = b_slope * b['Year'] + b_intercept\n\n    # Add linear regression line to the second subplot\n    fig.add_trace(go.Scatter(x=b['Year'], y=b_regression_line, mode='lines', name=f'Regression B: {b_slope:.2f}x + {b_intercept:.2f}', line=dict(color='lightcoral')), row=2, col=1)\n\n    # Set the common x-axis range for both subplots\n    fig.update_xaxes(range=x_range, row=1, col=1)\n    fig.update_xaxes(range=x_range, row=2, col=1)\n\n    # Set the common y-axis range for both subplots\n    fig.update_yaxes(range=y_range, row=1, col=1)\n    fig.update_yaxes(range=y_range, row=2, col=1)\n    \n    fig.update_xaxes(title_text='Year', row=2, col=1)\n    fig.update_yaxes(title_text='Temperature', row=1, col=1)\n    fig.update_yaxes(title_text='Temperature', row=2, col=1)\n\n    # Update layout if needed\n    fig.update_layout(showlegend=True)  # Optional: set showlegend=False if you don't want legends for each subplot\n\n    return fig\n\n\ndef four_season_plot(a, b, c, d, season_a, season_b, season_c, season_d):\n    \"\"\"\n    Generate a four-subplot plot comparing temperature trends for four different seasons over the years.\n\n    Parameters:\n    - a, b, c, d (pd.DataFrame): DataFrames for temperature data of four different seasons.\n    - season_a, season_b, season_c, season_d (str): Names or identifiers for the four seasons.\n\n    Returns:\n    - plotly.graph_objs.Figure: Four-subplot line plots with linear regression lines for each season.\n\n    Example:\n    ```python\n    fig = four_season_plot(df_season_spring, df_season_summer, df_season_fall, df_season_winter, 'Spring', 'Summer', 'Fall', 'Winter')\n    fig.show()\n    ```\n    \"\"\"\n    # Find the common x-axis range for all DataFrames\n    x_range = [min(min(a['Year']), min(b['Year']), min(c['Year']), min(d['Year'])),\n               max(max(a['Year']), max(b['Year']), max(c['Year']), max(d['Year']))]\n\n    # Calculate y_range\n    y_range = [min(min(a['MinTemp']), min(b['MinTemp']), min(c['MinTemp']), min(d['MinTemp'])),\n               max(max(a['MaxTemp']), max(b['MaxTemp']), max(c['MaxTemp']), max(d['MaxTemp']))]\n\n    # Create subplots with 4 rows and 1 column\n    fig = sp.make_subplots(rows=4, cols=1, subplot_titles=[f'{season_a} Temperature Over Years', f'{season_b} Temperature Over Years', f'{season_c} Temperature Over Years', f'{season_d} Temperature Over Years'], vertical_spacing=0.1)\n\n    # Add line plot for DataFrame 'a' to the first subplot\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['AvgTemp'], mode='lines', name='Avg Temperature', line=dict(color='black')), row=1, col=1)\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['MinTemp'], mode='lines', name='Min Temperature', line=dict(color='rgba(0, 0, 255, 0.3)')), row=1, col=1)\n    fig.add_trace(go.Scatter(x=a['Year'], y=a['MaxTemp'], mode='lines', name='Max Temperature', line=dict(color='rgba(255, 0, 0, 0.3)')), row=1, col=1)\n\n    # Calculate linear regression for DataFrame 'a'\n    a_slope, a_intercept = np.polyfit(a['Year'], a['AvgTemp'], 1)\n    a_regression_line = a_slope * a['Year'] + a_intercept\n\n    # Add linear regression line to the first subplot\n    fig.add_trace(go.Scatter(x=a['Year'], y=a_regression_line, mode='lines', name=f'Regression A: {a_slope:.2f}x + {a_intercept:.2f}', line=dict(color='lightblue')), row=1, col=1)\n\n    i = 2\n    for data in (b, c, d):\n        # Add line plot for DataFrame 'b' to the second subplot\n        fig.add_trace(go.Scatter(x=data['Year'], y=data['AvgTemp'], mode='lines', name='Avg Temperature', line=dict(color='black'), showlegend=False), row=i, col=1)\n        fig.add_trace(go.Scatter(x=data['Year'], y=data['MinTemp'], mode='lines', name='Min Temperature', line=dict(color='rgba(0, 0, 255, 0.3)'), showlegend=False), row=i, col=1)\n        fig.add_trace(go.Scatter(x=data['Year'], y=data['MaxTemp'], mode='lines', name='Max Temperature', line=dict(color='rgba(255, 0, 0, 0.3)'), showlegend=False), row=i, col=1)\n\n        # Calculate linear regression for DataFrame 'b'\n        slope, intercept = np.polyfit(data['Year'], data['AvgTemp'], 1)\n        regression_line = slope * data['Year'] + intercept\n\n        # Add linear regression line to the second subplot\n        fig.add_trace(go.Scatter(x=data['Year'], y=regression_line, mode='lines', name=f\"Regression {i}: {slope:.2f}x + {intercept:.2f}\", line=dict(color='lightcoral')), row=i, col=1)\n\n        i += 1\n\n    for r in range(1, 5):\n        # Set the common x-axis range for all subplots\n        fig.update_xaxes(range=x_range, row=r, col=1)\n\n        # Set the common y-axis range for all subplots\n        fig.update_yaxes(range=y_range, row=r, col=1)\n\n        fig.update_yaxes(title_text='Temperature', row=r, col=1)\n\n    # Update layout if needed\n    fig.update_xaxes(title_text='Year', row=4, col=1)\n    fig.update_layout(showlegend=True)  # Optional: set showlegend=False if you don't want legends for each subplot\n\n    return fig\n\nThe season_plot will notify you the latitude you inputted is locate in which climate zone and the yearly temprature of that zone in different seasons.\n\ndef season_plot(la_lower, la_upper, db_file='HW1.db'):\n    \"\"\"\n    Generate temperature plots for different seasons based on latitude range.\n\n    Parameters:\n    - la_lower, la_upper (float): Latitude range for temperature data.\n    - db_file (str): Database file containing temperature data. Default is 'HW1.db'.\n\n    Returns:\n    - plotly.graph_objs.Figure: Temperature plots based on latitude range and seasons.\n\n    Example:\n    ```python\n    fig = season_plot(-40, -23.5, 'climate_data.db')\n    fig.show()\n    ```\n    \"\"\"\n    df = allyear_climate_region_database(db_file, la_lower, la_upper)\n\n    # Northern Tropical Zone (0-23.5)\n    if 0 &lt;= la_lower &lt;= 23.5 and 0 &lt;= la_upper &lt;= 23.5:\n        print('This latitude range is in the Northern Tropical Zone and it has only 2 seasons!')\n        filter1 = df[df['Month'].isin([10, 1, 2, 3])]  # Dry season\n        avg1 = filter1.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg1.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        filter2 = df[df['Month'].isin([4, 5, 6, 7, 8, 9])]  # Wet season\n        avg2 = filter2.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg2.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        a = avg1\n        b = avg2\n        season_a = 'Dry Season'\n        season_b = 'Wet Season'\n        return two_season_plot(a, b, season_a, season_b)\n\n    # Southern Tropical Zone (-23.5 to 0)\n    if -23.5 &lt;= la_lower &lt;= 0 and -23.5 &lt;= la_upper &lt;= 0:\n        print('This latitude range is in the Southern Tropical Zone and it has only 2 seasons!')\n        a = avg2\n        b = avg1\n        season_a = 'Dry Season'\n        season_b = 'Wet Season'\n        return two_season_plot(a, b, season_a, season_b)\n\n    # Northern Subtropical Zone (23.5-40)\n    if 23.5 &lt;= la_lower &lt;= 40 and 23.5 &lt;= la_upper &lt;= 40:\n        print('This latitude range is in the Northern Subtropical Zone and it has only 2 seasons!')\n        filter1 = df[df['Month'].isin([10, 1, 2, 3])]  # Hot summer\n        avg1 = filter1.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg1.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        filter2 = df[df['Month'].isin([4, 5, 6, 7, 8, 9])]  # Wet season\n        avg2 = filter2.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg2.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        a = avg1\n        b = avg2\n        season_a = 'Summer Season'\n        season_b = 'Mild Winter Season'\n        return two_season_plot(a, b, season_a, season_b)\n\n    # Southern Subtropical Zone (-40 to -23.5)\n    if -40 &lt;= la_lower &lt;= -23.5 and -40 &lt;= la_upper &lt;= -23.5:\n        print('This latitude range is in the Southern Subtropical Zone and it has only 2 seasons!')\n        a = avg2\n        b = avg1\n        season_a = 'Summer Season'\n        season_b = 'Mild Winter Season'\n        return two_season_plot(a, b, season_a, season_b)\n\n    # Northern Temperate Zone (40-60)\n    if 40 &lt;= la_lower &lt;= 60 and 40 &lt;= la_upper &lt;= 60:\n        print('This latitude range is in the Northern Temperate Zone and it has 4 seasons!')\n        filter1 = df[df['Month'].isin([3, 4, 5])]  # Spring\n        avg1 = filter1.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg1.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        filter2 = df[df['Month'].isin([6, 7, 8])]  # Summer\n        avg2 = filter2.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg2.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        filter3 = df[df['Month'].isin([9, 10, 11])]  # Autumn\n        avg3 = filter3.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg3.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        filter4 = df[df['Month'].isin([12, 1, 2])]  # Winter\n        avg4 = filter4.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg4.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        a = avg1\n        b = avg2\n        c = avg3\n        d = avg4\n        season_a = 'Spring'\n        season_b = 'Summer'\n        season_c = 'Autumn'\n        season_d = 'Winter'\n        return four_season_plot(a, b, c, d, season_a, season_b, season_c, season_d)\n\n    # Southern Temperate Zone (-60 to -40)\n    if -60 &lt;= la_lower &lt;= -40 and -60 &lt;= la_upper &lt;= -40:\n        print('This latitude range is in the Southern Temperate Zone and it has 4 seasons!')\n        a = avg3\n        b = avg4\n        c = avg1\n        d = avg2\n        season_a = 'Spring'\n        season_b = 'Summer'\n        season_c = 'Autumn'\n        season_d = 'Winter'\n        return four_season_plot(a, b, c, d, season_a, season_b, season_c, season_d)\n\n    # Northern Cold Zone (60-90)\n    if 60 &lt;= la_lower &lt;= 90 and 60 &lt;= la_upper &lt;= 90:\n        print('This latitude range is in the Northern Cold Zone and it has 4 seasons!')\n        filter1 = df[df['Month'].isin([3, 4, 5])]  # Spring\n        avg1 = filter1.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg1.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        filter2 = df[df['Month'].isin([6, 7, 8])]  # Summer\n        avg2 = filter2.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg2.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        filter3 = df[df['Month'].isin([9, 10, 11])]  # Autumn\n        avg3 = filter3.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg3.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        filter4 = df[df['Month'].isin([12, 1, 2])]  # Winter\n        avg4 = filter4.groupby('Year')['Temp'].agg(['mean', 'max', 'min']).reset_index()\n        avg4.columns = ['Year', 'AvgTemp', 'MaxTemp', 'MinTemp']\n\n        a = avg1\n        b = avg2\n        c = avg3\n        d = avg4\n        season_a = 'Spring'\n        season_b = 'Summer'\n        season_c = 'Autumn'\n        season_d = 'Winter'\n        return four_season_plot(a, b, c, d, season_a, season_b, season_c, season_d)\n\n    warning = 'Your latitude should be inside the range of each zone!'\n    return warning\n\n\n# let's try out the Northern Cold Zone\nresult = season_plot(60, 90)\n\nThis latitude range is in the Northern Cold Zone and it has 4 seasons!\n\n\n\nresult.update_layout(height=600, width=1000)\nresult.show()\n\n                                                \n\n\nHere you could do the experiment by yourself with different latitude. I plug in 60 and 90, which is in Northern Cold Zone and it has 4 seasons. The overall temperature is low compare to other places and the linear line of average temperature is nearly flat, which indicates a not much of difference among the temperatures over years. Other than that, Spring and Fall share the same distribution, Summer being the overall hottest, and Winter being the overall coldest.\n\n\nDoes the Global Warming effect differently in these 4 climate zones?\nTo answer this question, for each zone, we can plot the yearly average temperature for each zone.\n\n# Retrieving climate data for different latitude ranges to analyze specific climate zones\n\n# Tropical Zone: Latitude between -23.5 and 23.5 degrees\ntropical = allyear_climate_region_database('HW1.db', -23.5, 23.5)\n\n# Subtropical Zone: Latitude between 23.5 and 40 degrees (sub1) and -40 to -23.5 degrees (sub2)\nsub1 = allyear_climate_region_database('HW1.db', 23.5, 40)\nsub2 = allyear_climate_region_database('HW1.db', -40, -23.5)\nsub = pd.concat([sub1, sub2], ignore_index=True)\n\n# Temperate Zone: Latitude between 40 and 60 degrees (temperate1) and -60 to -40 degrees (temperate2)\ntemperate1 = allyear_climate_region_database('HW1.db', 40, 60)\ntemperate2 = allyear_climate_region_database('HW1.db', -60, -40)\ntemperate = pd.concat([temperate1, temperate2], ignore_index=True)\n\n# Cold Zone: Latitude between 60 and 90 degrees\ncold = allyear_climate_region_database('HW1.db', 60, 90)\n\n# Calculate average yearly temperature for each climate zone\ntro_avg = tropical.groupby('Year')['Temp'].mean()\nsub_avg = sub.groupby('Year')['Temp'].mean()\ntemperate_avg = temperate.groupby('Year')['Temp'].mean()\ncold_avg = cold.groupby('Year')['Temp'].mean()\n\n\nfig = go.Figure()\n\n# Add trace for tropical dataset\nfig.add_trace(go.Scatter(x=tro_avg.index, y=tro_avg.values, mode='markers', name='Tropical', line=dict(color='blue')))\n\n# Add trace for sub dataset\nfig.add_trace(go.Scatter(x=sub_avg.index, y=sub_avg.values, mode='markers', name='Subtropical', line=dict(color='green')))\n\n# Add trace for temperate dataset\nfig.add_trace(go.Scatter(x=temperate_avg.index, y=temperate_avg.values, mode='markers', name='Temperate', line=dict(color='orange')))\n\n# Add trace for cold dataset\nfig.add_trace(go.Scatter(x=cold_avg.index, y=cold_avg.values, mode='markers', name='Cold', line=dict(color='red')))\n\n# Update layout for better readability\nfig.update_layout(title='Yearly Average Temperature',\n                  xaxis_title='Year',\n                  yaxis_title='Temperature',\n                  legend=dict(title='Dataset'))\n\n# Show the plot\nfig.show()\n\n                                                \n\n\nThe overall Yearly Average Temperature for each climate zone did not change a lot throughout years but with a slight increase for each scatter line especially for the cold and tropical zone. However, from the average temperature, we could barely see the global warming effect. There are more infos that we need to investigate!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jamie’s Blog",
    "section": "",
    "text": "Post With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nJan 11, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 8, 2024\n\n\nJiaxin Luo\n\n\n\n\n\n\n\n\n\n\n\n\nGlobal Warming: Data Wrangling and Visualization\n\n\n\n\n\n\nHOMEWORK\n\n\n\n\n\n\n\n\n\nJan 28, 2023\n\n\nJamie\n\n\n\n\n\n\n\n\n\n\n\n\nPenguin World\n\n\n\n\n\n\nHOMEWORK\n\n\n\n\n\n\n\n\n\nJan 21, 2023\n\n\nJamie\n\n\n\n\n\n\nNo matching items"
  }
]